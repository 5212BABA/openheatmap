<?xml version="1.0" encoding="utf-8"?>

<!--
OpenGraphMap renderer - a flash component to display and explore map visualizations
Copyright (C) 2010 Pete Warden <pete@petewarden.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" 
    width="800" height="600" 
    applicationComplete="startup()">

<mx:Script>
<![CDATA[

import mx.controls.Label;
import flash.external.ExternalInterface; 
import mx.controls.Text;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import mx.controls.sliderClasses.Slider;
import mx.controls.VSlider;
import mx.core.BitmapAsset;
import mx.events.SliderEvent;

import TimelineControls;

public var _mainShape:Shape = null;
public var _mainBitmap: Bitmap = null;
public var _dirty: Boolean = true;
public var _redrawCountdown: int = 0;
public var _oceanColor: Number = 0xd0e0ff;

public var _wayDefaults: Object = {
	color: 0x000000,
	alpha: 1.0,
	line_thickness: 0
};

public var _colorGradient: Array = [
	{red: 0x00, green: 0xb0, blue: 0x00},
	{red: 0xe0, green: 0xe0, blue: 0x00},
	{red: 0xff, green: 0x00, blue: 0x00},
];

public var _highlightColor: Number = 0xff0000;

public var _onClickFunction: String = null;
public var _onDoubleClickFunction: String = null;
public var _onMouseDownFunction: String = null;
public var _onMouseUpFunction: String = null;
public var _onMouseOverFunction: String = null;
public var _onMouseOutFunction: String = null;
public var _onMouseMoveFunction: String = null;
public var _onFrameRenderFunction: String = null;
public var _onDataChangeFunction: String = null;
public var _onWaysLoadFunction: String = null;
public var _onValuesLoadFunction: String = null;
public var _onErrorFunction: String = null;

public var _width: Number = 800;
public var _height: Number = 600;

public var _nodes: Object = {};
public var _ways: Object = {};

public var _waysLoader: URLLoader;
public var _waysFileName: String = "";

public var _valuesLoader: URLLoader;
public var _valuesFileName: String = "";

public var _valueHeaders: Array = null;
public var _valueData: Array = null;
public var _timeColumnIndex: int;
public var _valueColumnIndex: int;

public var _smallestValue: Number;
public var _largestValue: Number;

public var _hasTime: Boolean = false;
public var _frameTimes: Array = [];
public var _frameIndex: Number = 0;

public var _tagMap: Object = {};

public var _latLonToXYMatrix: Matrix = new Matrix();
public var _xYToLatLonMatrix: Matrix = new Matrix();

public var _worldBoundingBox: Rectangle = new Rectangle();
public var _bucketGridRows: int = 16;
public var _bucketGridColumns: int = 16;
public var _bucketGrid: Array = [];

public var _timelineControls: TimelineControls = null;

public var _inlays: Array = [];

public var _valuesDirty: Boolean = false;

public var _mainBitmapTopLeftLatLon: Object = null;
public var _mainBitmapBottomRightLatLon: Object = null;

public var _isDragging: Boolean = false;
public var _lastDragPosition: Point = null;
public var _lastClickTime: Number = 0;

public var _zoomSlider: Slider = null;
[Embed(source="images/plus.gif")]
public var PlusImage:Class;
[Embed(source="images/minus.gif")]
public var MinusImage:Class;
public var _zoomSliderPower: Number = 5.0;
public var _zoomedOutDegreesPerPixel: Number = -180;
public var _zoomedInDegreesPerPixel: Number = -0.01;

public var _isGradientValueRangeSet: Boolean = false;
public var _gradientValueMin: Number;
public var _gradientValueMax: Number;

public var _foundTimes: Object = {};
public var _timeRangeStart: String = null;
public var _timeRangeEnd: String = null;

public var _hasBitmapBackground: Boolean = true;//false;
public var _bitmapBackgroundResolution: int = 4;

public var _hasPointValues: Boolean = false;
public var _latitudeColumnIndex: int = -1;
public var _longitudeColumnIndex: int = -1;

private function getURLInput(name: String, defaultValue: String = null): String
{
	if (mx.core.Application.application.parameters.hasOwnProperty(name))
		return mx.core.Application.application.parameters[name];
	else
		return defaultValue;
}
	
public function startup():void
{
	setSize(800, 600);

	createViewerElements();

	setLatLonViewingArea(90, -180, -90, 180);
		    
    viewer.addEventListener( MouseEvent.CLICK, mapMouseClickHandler );
	// Pete- I'm synthesizing double-click events, see the single click handler for details
//    viewer.addEventListener( MouseEvent.DOUBLE_CLICK, mapMouseDoubleClickHandler );
    viewer.addEventListener( MouseEvent.MOUSE_DOWN, mapMouseDownHandler );
    viewer.addEventListener( MouseEvent.MOUSE_MOVE, mapMouseMoveHandler );
    viewer.addEventListener( MouseEvent.MOUSE_OUT, mapMouseOutHandler );
    viewer.addEventListener( MouseEvent.MOUSE_OVER, mapMouseOverHandler );
    viewer.addEventListener( MouseEvent.MOUSE_UP, mapMouseUpHandler );
//    viewer.addEventListener( MouseEvent.MOUSE_WHEEL, mapMouseWheelHandler );
//	viewer.doubleClickEnabled = true;

	_dirty = true;

	addEventListener(Event.ENTER_FRAME, doEveryFrame);
	
	ExternalInterface.addCallback("setSize", setSize);      	
	ExternalInterface.addCallback("setLatLonViewingArea", setLatLonViewingArea);      	
	ExternalInterface.addCallback("setOceanColor", function(color: Number): void { _oceanColor = color; _dirty = true; });
	ExternalInterface.addCallback("setWayDefault", setWayDefault);
	ExternalInterface.addCallback('setEventHandler', setEventHandler);
	ExternalInterface.addCallback("loadWaysFromFile", loadWaysFromFile);      	
	ExternalInterface.addCallback("loadValuesFromFile", loadValuesFromFile);
	ExternalInterface.addCallback("setColorGradient", setColorGradient);	
	ExternalInterface.addCallback("getWaysContainingLatLon", getWaysContainingLatLon);
	ExternalInterface.addCallback("getValueForWayId", getValueForWayId);
	ExternalInterface.addCallback("addInlay", addInlay);
	ExternalInterface.addCallback("translateMapByScreenPixels", translateMapByScreenPixels);
	ExternalInterface.addCallback("zoomMapByFactorAroundPoint", zoomMapByFactorAroundPoint);
	ExternalInterface.addCallback("getPixelsPerDegreeLatitude", getPixelsPerDegreeLatitude);
	ExternalInterface.addCallback("setPixelsPerDegreeLatitude", setPixelsPerDegreeLatitude);
	ExternalInterface.addCallback("setGradientValueRange", setGradientValueRange);
	ExternalInterface.addCallback("setTimeRange", setTimeRange);
	ExternalInterface.addCallback("getWayForWayId", getWayForWayId);

	var onLoadFunction: String = getURLInput('onload', 'onMapCreated');
	if (onLoadFunction !== null)
		ExternalInterface.call(onLoadFunction, '');
}

private function setWayDefault(propertyName: String, propertyValue: Object): void
{
	_wayDefaults[propertyName] = propertyValue;
	_dirty = true;
}

private function getWayProperty(propertyName: String, wayInfo: Object = null): Object
{
	if ((wayInfo !== null) && (wayInfo.hasOwnProperty(propertyName)))
		return wayInfo[propertyName];
	else if (_wayDefaults.hasOwnProperty(propertyName))
		return _wayDefaults[propertyName];
	else
		return null;
}

private function doTagsMatch(tags: Array, lineInfo: Object): Boolean
{
	var result: Boolean = false;
	if (tags === null)
	{
		result = true;
	}
	else
	{
		if (lineInfo.hasOwnProperty('tags'))
		{
			var myTags: Array = lineInfo.tags;
			
			for each (var myTag: String in myTags)
			{
				for each (var tag: String in tags)
				{
					if (myTag === tag)
						result = true;
				}
			}
			
		}
	}
		
	return result;
}

private function getTagsFromArgument(tagsArgument: Object): Array
{
	if (tagsArgument === null)
		return null;
		
	if (tagsArgument is Array)
		return tagsArgument as Array;
	else
		return [ tagsArgument ];
}

private function setEventHandler(eventName: String, functionName: String): void
{
	eventName = eventName.toLowerCase();
	
	if (eventName == 'click')
		_onClickFunction = functionName;
	else if (eventName == 'doubleclick')
		_onDoubleClickFunction = functionName;
	else if (eventName == 'mousedown')
		_onMouseDownFunction = functionName;
	else if (eventName == 'mouseup')
		_onMouseUpFunction = functionName;
	else if (eventName == 'mouseover')
		_onMouseOverFunction = functionName;
	else if (eventName == 'mouseout')
		_onMouseOutFunction = functionName;
	else if (eventName == 'mousemove')
		_onMouseMoveFunction = functionName;
	else if (eventName == 'framerender')
		_onFrameRenderFunction = functionName;
	else if (eventName == 'datachange')
		_onDataChangeFunction = functionName;
	else if (eventName == 'waysload')
		_onWaysLoadFunction = functionName;
	else if (eventName == 'valuesload')
		_onValuesLoadFunction = functionName;
	else if (eventName == 'error')
		_onErrorFunction = functionName;
	else
		logError( 'Unknown event name passed to MapRender::setEventHandler - "'+
			eventName+'" (expected click, doubleclick, mousedown, mouseup, mouseover, mouseout, framerender, datachange, waysload, valuesload or error)');
}

private function setSize(width: Number, height: Number): void
{
	_width = width;
	_height = height;
	
	if (_timelineControls !== null)
		_timelineControls.setWidth(width);
	
	_dirty = true;	
}

private function setLatLonViewingArea(topLat: Number, leftLon: Number, bottomLat: Number, rightLon: Number): void
{
	var widthLon: Number = (rightLon-leftLon);
	var heightLat: Number = (bottomLat-topLat);
	
	var scaleX: Number = (_width/widthLon);
	var scaleY: Number = (_height/heightLat);

	var newMatrix: Matrix = new Matrix();
	newMatrix.translate(-leftLon, -topLat);
	newMatrix.scale(scaleX, scaleY);

	setLatLonToXYMatrix(newMatrix);
}

private function setLatLonToXYMatrix(newMatrix: Matrix): void
{
	_latLonToXYMatrix = newMatrix;
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();
	
	updateZoomSliderDisplay();
}

private function getXYFromLatLon(latLon: Object, latLonToXYMatrix: Matrix): Point
{
	var latLonPoint: Point = new Point(latLon.lon, latLon.lat);
	
	var result: Point = latLonToXYMatrix.transformPoint(latLonPoint);

	return result;
}

private function getLatLonFromXY(xYPoint: Point, xYToLatLonMatrix: Matrix): Object
{
	var latLonPoint: Point = xYToLatLonMatrix.transformPoint(xYPoint);
	
	var result: Object = {
			lat: latLonPoint.y,
			lon: latLonPoint.x
	}
	
	return result;
}

private function makeEventArgument(event:MouseEvent): Object
{
	var mouseX: Number = event.stageX;
	var mouseY: Number = event.stageY;

	var mainLatLon: Object = getLatLonFromXY(new Point(mouseX, mouseY), _xYToLatLonMatrix);
	
	var mouseLatLon: Object = null;
	for each (var inlay: Object in _inlays)
	{
		var screenTopLeft: Point = getXYFromLatLon(inlay.worldTopLeftLatLon, _latLonToXYMatrix);
		var screenBottomRight: Point = getXYFromLatLon(inlay.worldBottomRightLatLon, _latLonToXYMatrix);

		if ((mouseX>=screenTopLeft.x)&&
			(mouseX<screenBottomRight.x)&&
			(mouseY>=screenTopLeft.y)&&
			(mouseY<screenBottomRight.y))
		{
			var localX: Number = (mouseX-screenTopLeft.x);
			var localY: Number = (mouseY-screenTopLeft.y);
			mouseLatLon = getLatLonFromXY(new Point(localX, localY), inlay.xYToLatLonMatrix);
		}
	}
	
	if (mouseLatLon === null)
		mouseLatLon = mainLatLon;
	
	var mapPointData:Object = new Object();
	mapPointData.lon = mouseLatLon.lon;
	mapPointData.lat = mouseLatLon.lat;
	mapPointData.x = mouseX;
	mapPointData.y = mouseY;

	return mapPointData;
}
	
private function mapMouseClickHandler( event:MouseEvent ): Boolean
{
	var continueHandling: Boolean;
	if (_onClickFunction !== null)
		continueHandling = ExternalInterface.call(_onClickFunction, makeEventArgument(event));
	else
		continueHandling = true;

	// Pete - I can't get double-click events to fire reliably, so I've hard-coded an interval within which the
	// second normal click event triggers the double-click handler. Ugh, I feel dirty...
	var currentTime: Number = new Date().getTime();
	var sinceLastClick: Number = (currentTime-_lastClickTime);
	if (sinceLastClick<750)
	{
		mapMouseDoubleClickHandler(event);
		_lastClickTime = 0;
	}
	else
	{
		_lastClickTime = currentTime;	
	}
		
	return true;
}

private function mapMouseDoubleClickHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onDoubleClickFunction !== null)
		continueHandling = ExternalInterface.call(_onDoubleClickFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	if (continueHandling)
	{
		var center: Point = new Point(event.localX, event.localY);
		var zoomFactor: Number = 2.0;
		
		zoomMapByFactorAroundPoint(zoomFactor, center);
	}
		
	return true;
}

private function mapMouseDownHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseDownFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseDownFunction, makeEventArgument(event));
	else
		continueHandling = true;
	
	if (continueHandling)
	{
		var mousePosition: Point = new Point(event.localX, event.localY);

		_isDragging = true;
		_lastDragPosition = mousePosition; 
	}
	
	return true;
}

private function mapMouseUpHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseUpFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseUpFunction, makeEventArgument(event));
	else
		continueHandling = true;
	
	if (continueHandling)
	{
		if (_isDragging)
		{
			var mousePosition: Point = new Point(event.localX, event.localY);
	
			var positionChange: Point = mousePosition.subtract(_lastDragPosition);
	
			translateMapByScreenPixels(positionChange.x, positionChange.y, false);
	
			_isDragging = false;
		}
	}
	
	return true;
}

private function mapMouseOverHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseOverFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseOverFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	return true;
}

private function mapMouseOutHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseOutFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseOutFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	return true;
}

private function mapMouseMoveHandler( event:MouseEvent): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseMoveFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseMoveFunction, makeEventArgument(event));
	else
		continueHandling = true;

	if (continueHandling)
	{
		if (_isDragging)
		{
			var mousePosition: Point = new Point(event.localX, event.localY);
	
			var positionChange: Point = mousePosition.subtract(_lastDragPosition);
	
			translateMapByScreenPixels(positionChange.x, positionChange.y, true);
	
			_lastDragPosition = mousePosition;
		}
	}
			
	return true;
}

private function doEveryFrame(event: Event): void
{		
	if (_redrawCountdown>0)
	{
		_redrawCountdown -= 1;
		if (_redrawCountdown===0)
			_dirty = true;
	}
	
	if (_valuesDirty&&(_redrawCountdown===0))
	{
		if (!_hasPointValues)
			setWaysFromValues();
		_valuesDirty = false;		
	}
	
	if (_dirty)
	{		
		drawMapIntoMainBitmap();
				
		_dirty = false;
		_redrawCountdown = 0;
	}
	
	drawMainBitmapIntoViewer();
	
	if (_hasTime)
	{
		if (_timelineControls.isPlaying)
		{
			_frameIndex += 1;
			if (_frameIndex>=_frameTimes.length)
			{
				_frameIndex = (_frameTimes.length-1);
				_timelineControls.isPlaying = false;
			}
			
			updateTimelineDisplay();
			
			_dirty = true;
			_valuesDirty = true;
			onDataChange();
		}
	}

	if (_onFrameRenderFunction !== null)
		ExternalInterface.call(_onFrameRenderFunction, null);	
}

private function blankWay(): Object
{
	var result: Object = {};
	
	result.boundingBox = new Rectangle();
	result.nds = [];
	result.tags = {};
	result.isClosed = false;
	
	for each (var key:String in _wayDefaults)
	{
		result[key] = _wayDefaults[key];
	}

	return result;	
}

private function onWaysLoad(success:Boolean): void
{ 	  		  	
	var waysData:XML = XML(_waysLoader.data);
  	
  	_tagMap = {};
  	
  	for each (var node: * in waysData..node)
  	{
  		var newNode: Object = {
  				'lon': (Number)(node.@lon),
  				'lat': (Number)(node.@lat)
  		};
  		
  		_nodes[node.@id] = newNode;  		
  	}

  	for each (var way: * in waysData..way)
  	{
		var wayId: String = (String)(way.@id);

  		var newWay: Object = blankWay();
		newWay.id = wayId;
//		newWay.boundingBox = way.bound.@box.explode(',');

		var ndCount: Number = 0;
		var firstNd: String = null;
		var lastNd: String = null;
	  	for each (var nd: * in way..nd)
	  	{
	  		if (typeof _nodes[nd.@ref] === 'undefined')
	  			continue;

	  		ndCount += 1;
	  		newWay.nds.push(nd.@ref);
	  		
	  		if (firstNd===null)
	  			firstNd = nd.@ref;
	  		lastNd = nd.@ref;
	  			  			
	  		var thisNode: Object = _nodes[nd.@ref];
	  		var nodePos: Point = new Point(thisNode.lon, thisNode.lat);
	  		newWay.boundingBox = enlargeBoxToContain(newWay.boundingBox, nodePos);
	  	}
	  	
	  	newWay.isClosed = (firstNd===lastNd);
	  	
	  	for each (var tag: * in way..tag)
	  	{
	  		var key: String = tag.@k;
	  		var value: String = tag.@v;
	  		
	  		newWay.tags[key] = value;
	  		
	  		if (typeof _tagMap[key] === 'undefined')
	  			_tagMap[key] = {};
	  			
	  		if (typeof _tagMap[key][value] === 'undefined')
	  			_tagMap[key][value] = [];
	  			
	  		_tagMap[key][value].push(newWay.id);
	  	}
  		
  		_ways[wayId] = newWay;
  		
  		if (!newWay.boundingBox.isEmpty())
  		{
  			_worldBoundingBox = enlargeBoxToContain(_worldBoundingBox, newWay.boundingBox.topLeft);
  			_worldBoundingBox = enlargeBoxToContain(_worldBoundingBox, newWay.boundingBox.bottomRight);
  		}
  	}

	buildBucketGrid();
	_dirty = true;
	if (_onWaysLoadFunction!==null)
		ExternalInterface.call(_onWaysLoadFunction, _waysFileName);
}
 	  
private function loadWaysFromFile(waysFileName: String): void
{
 	_waysFileName = waysFileName;
    _waysLoader = new URLLoader(new URLRequest(waysFileName));
    _waysLoader.addEventListener("complete", onWaysLoad);
}

private function decodeCSVRow(line: String, columnSeperator: String = ',') : Array
{
	var inQuotes: Boolean = false;
	var inEscape: Boolean = false;
	
	var result: Array = [];

	var currentValue: String = '';

	for( var i: int = 0; i < line.length; i+=1)
	{
		var currentChar: String = line.charAt(i);
	
		if (!inQuotes)
		{
			if (currentChar==='"')
			{
				inQuotes = true;
			}
			else if (currentChar===columnSeperator)
			{
				result.push(currentValue);
				currentValue = '';
			}
			else
			{
				currentValue += currentChar;
			}
		}
		else
		{
			if (!inEscape)
			{
				if (currentChar==='\\')
				{
					inEscape = true;
				}
				else if (currentChar==='"')
				{
					inQuotes = false;
				}
				else
				{
					currentValue += currentChar;
				}
				
			}
			else
			{
				currentValue += currentChar;
				inEscape = false;
			}
			
		}
		
	}
	
	result.push(currentValue);
	
	return result;
}

private function onValuesLoad(success:Boolean): void
{
	var lineSeperator: String = '\n';
	var columnSeperator: String = ',';		  	

	var linesArray: Array = _valuesLoader.data.toString().split(lineSeperator);
	
	var headerLine: String = linesArray[0];

	_valueHeaders = decodeCSVRow(headerLine, columnSeperator);

	_timeColumnIndex = -1;
	_valueColumnIndex = -1;
	_latitudeColumnIndex = -1;
	_longitudeColumnIndex = -1;
	for(var headerIndex:int = 0; headerIndex < _valueHeaders.length; headerIndex++ )
	{
		var header: String = _valueHeaders[headerIndex].toLowerCase();
		if (header==='time')
			_timeColumnIndex = headerIndex;	
		else if (header==='value')
			_valueColumnIndex = headerIndex;
		else if ((header==='latitude')||(header==='lat'))
			_latitudeColumnIndex = headerIndex;
		else if ((header==='longitude')||(header==='lon'))
			_longitudeColumnIndex = headerIndex;
	}
	
	var hasLatitude: Boolean = (_latitudeColumnIndex!==-1);
	var hasLongitude: Boolean = (_longitudeColumnIndex!==-1);
	
	if ((hasLatitude||hasLongitude)&&(hasLatitude!=hasLongitude))
	{
		logError( 'Error loading CSV file "'+_valuesFileName+'" - only found one of longitude or latitude in "'+headerLine+'"');
		return;		
	}
	
	_hasPointValues = hasLatitude;
	_hasTime = (_timeColumnIndex!==-1);
	
	if (!_hasPointValues)
		loadAreaValues(linesArray, headerLine, columnSeperator);
	else
		loadPointValues(linesArray, headerLine, columnSeperator);
		
	if (_hasTime)
	{
		calculateFrameTimes();
		_frameIndex = 0;
		addTimelineControls();
	}
	
	_valuesDirty = true;
	_dirty = true;
	
	if (_onValuesLoadFunction!==null)
		ExternalInterface.call(_onValuesLoadFunction, _valuesFileName);
			
}
private function loadValuesFromFile(valuesFileName: String): void
{
	_valuesFileName = valuesFileName;
	_valuesLoader = new URLLoader(new URLRequest(valuesFileName));
	_valuesLoader.addEventListener("complete", onValuesLoad);
}

private function doRedraw(graphics: Graphics, width: Number, height: Number, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): void
{		
	graphics.clear();

	graphics.beginFill(_oceanColor, 1.0);
   	graphics.drawRect(0, 0, width, height);
    graphics.endFill();
    
	var viewingArea: Rectangle = new Rectangle();
	
	var topLeftScreen: Point = new Point(0, 0);
	var bottomRightScreen: Point = new Point(width, height);
		
	var topLeftLatLon: Object = getLatLonFromXY(topLeftScreen, xYToLatLonMatrix);
	var bottomRightLatLon: Object = getLatLonFromXY(bottomRightScreen, xYToLatLonMatrix);
	
	viewingArea = enlargeBoxToContain(viewingArea, new Point(topLeftLatLon.lon, topLeftLatLon.lat));
	viewingArea = enlargeBoxToContain(viewingArea, new Point(bottomRightLatLon.lon, bottomRightLatLon.lat));	

    var bitmapBackground: BitmapData = null;
    if (_hasBitmapBackground)
    	bitmapBackground = createBitmapBackground(width, height, viewingArea, latLonToXYMatrix, xYToLatLonMatrix);

	drawWays(graphics, viewingArea, latLonToXYMatrix, bitmapBackground);
}

private function drawWays(graphics: Graphics, viewingArea: Rectangle, latLonToXYMatrix: Matrix, bitmapBackground: BitmapData): void
{
	var hasBitmap: Boolean = (bitmapBackground!==null);
	var bitmapMatrix: Matrix = new Matrix();
	bitmapMatrix.scale(_bitmapBackgroundResolution, _bitmapBackgroundResolution);
	
	for (var wayId:String in _ways)
	{
		var way: Object = _ways[wayId];
		var wayColor: Number;
		var wayAlpha: Number;
		if (getWayProperty('highlighted', way)==true)
		{
			wayColor = Number(getWayProperty('highlightColor', way));
			wayAlpha = Number(getWayProperty('highlightAlpha', way));
		}
		else
		{
			wayColor = Number(getWayProperty('color', way));
			wayAlpha = Number(getWayProperty('alpha', way));
		}

		if (way.nds.length<1)
			continue;
		
		if (!viewingArea.intersects(way.boundingBox))
			continue;

		var isClosed: Boolean = way.isClosed;			

		if (isClosed)
		{		
			var finalNd: String = way.nds[way.nds.length-1];
			var finalNode: Object = _nodes[finalNd];
			
			var finalPos: Point = getXYFromLatLon(finalNode, latLonToXYMatrix);

			graphics.lineStyle();
			if (hasBitmap)
				graphics.beginBitmapFill(bitmapBackground, bitmapMatrix, false, true);
			else
				graphics.beginFill(wayColor, wayAlpha);
			
			graphics.moveTo(finalPos.x, finalPos.y);
		}
		else
		{
			var firstNd: String = way.nds[0];
			var firstNode: Object = _nodes[firstNd];
			
			var firstPos: Point = getXYFromLatLon(firstNode, latLonToXYMatrix);

			graphics.lineStyle(0, wayColor,wayAlpha);

			graphics.moveTo(firstPos.x, firstPos.y);
		}

		for each (var currentNd: String in way.nds)
		{
			var currentNode: Object = _nodes[currentNd];
			var currentPos: Point = getXYFromLatLon(currentNode, latLonToXYMatrix);
			
			graphics.lineTo(currentPos.x, currentPos.y);
		}

		if (isClosed)
		{
			graphics.endFill();
		}
	}
	
	if (_hasPointValues)
	{
		graphics.lineStyle(0, 0x000000, 1.0);

		for each (var values: Array in _valueData)
		{
			var latLon: Object = { 
				lat: values[_latitudeColumnIndex],
				lon: values[_longitudeColumnIndex]
			};

			currentPos = getXYFromLatLon(latLon, latLonToXYMatrix);
	
			graphics.drawCircle(currentPos.x, currentPos.y, 1);
		}	
	}
}

private function setWaysFromValues(): void
{
	if (_valueData === null)
		return;

	if (_isGradientValueRangeSet)
	{
		var minValue: Number = _gradientValueMin;
		var maxValue: Number = _gradientValueMax;	
	}
	else
	{
		minValue = _smallestValue;
		maxValue = _largestValue;
	}
	var valueScale: Number = (1/(maxValue-minValue));

	var currentValues: Array;
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = _valueData[currentTime];
	}
	else
	{
		currentValues = _valueData;
	}
	
	for each (var values: Array in currentValues)
	{
		if (_hasTime)
		{
			var thisTime: String = values[_timeColumnIndex];
			if (thisTime !== currentTime)
				continue;
		}

		var matchKeys: Object = {};
		var thisValue: Number = 0;		
		for (var i:int = 0; i<values.length; i+=1)
		{
			if (i===_valueColumnIndex)
			{
				thisValue = (Number)(values[i]);
			}
			else if (i!==_timeColumnIndex)
			{
				var headerName: String = _valueHeaders[i];
				matchKeys[headerName] = values[i];	
			}
		}
		
		var normalizedValue: Number = ((thisValue-minValue)*valueScale); 
		normalizedValue = Math.min(normalizedValue, 1.0);
		normalizedValue = Math.max(normalizedValue, 0.0);
		
		var fractionalIndex: Number = (normalizedValue*(_colorGradient.length-1));
		
		var lowerIndex: int = Math.floor(fractionalIndex);
		var higherIndex: int = Math.ceil(fractionalIndex);
		var lerpValue: Number = (fractionalIndex-lowerIndex);
		var oneMinusLerp: Number = (1.0-lerpValue);
		
		var lowerValue: Object = _colorGradient[lowerIndex];
		var higherValue: Object = _colorGradient[higherIndex];
		
		var red: int = (int)((lowerValue.red*oneMinusLerp)+(higherValue.red*lerpValue));
		var green: int = (int)((lowerValue.green*oneMinusLerp)+(higherValue.green*lerpValue));
		var blue: int = (int)((lowerValue.blue*oneMinusLerp)+(higherValue.blue*lerpValue));
		
		var setColor: int = ((red<<16)|(green<<8)|(blue<<0));
		
		setAttributeForMatchingWays(matchKeys, 'color', (String)(setColor));
	}
	
}

private function setColorGradient(colorList: Array) : void
{
	_colorGradient = [];
	
	for each (var colorString: String in colorList)
	{
		var colorNumber: Number = (Number)(colorString);
		var red: Number = (colorNumber&0xff0000)>>16;
		var green: Number = (colorNumber&0x00ff00)>>8;
		var blue: Number = (colorNumber&0x0000ff)>>0;
		
		_colorGradient.push({
			red: red,
			green: green,
			blue: blue
		});
	}	
}

private function setAttributeForMatchingWays(matchKeys: Object, attributeName: String, attributeValue: String) : void
{
	var matchingWayIds: Object = null;
	for (var key:String in matchKeys)
	{
		var value: String = matchKeys[key];
		
		var currentMatches: Array;
		if (typeof _tagMap[key][value] === 'undefined')
			currentMatches = [];
		else
		 	currentMatches = _tagMap[key][value];
		 
		if (matchingWayIds === null)
		{
			matchingWayIds = {};
			for each (var wayId: String in currentMatches)
				matchingWayIds[wayId] = true;
		}
		else
		{
			var previousMatchingWayIds: Object = matchingWayIds;
			matchingWayIds = {};
			for each (wayId in currentMatches)
			{
				if (typeof previousMatchingWayIds[wayId] !== 'undefined')
					matchingWayIds[wayId] = true;
			}
		}
	}
		
	var foundCount: Number = 0;
	for (wayId in matchingWayIds)
	{
		_ways[wayId][attributeName] = attributeValue;
		foundCount += 1;		
	}

//	if (foundCount===0)
//	{
//		trace('No match found for');
//		for (key in matchKeys)
//		{
//			value = matchKeys[key];	
//			trace(key+':'+value);
//		}
//	}

}

private function enlargeBoxToContain(box: Rectangle, pos: Point): Rectangle
{
	if (box.containsPoint(pos))
		return box;
	
	if ((box.x==0)&&
		(box.y==0)&&
		(box.width==0)&&
		(box.height==0))
		return new Rectangle(pos.x, pos.y, 0, 0);
		
	if (box.left>pos.x)
		box.left = pos.x;

	if (box.right<pos.x)
		box.right = pos.x;

	if (box.top>pos.y)
		box.top = pos.y;
		
	if (box.bottom<pos.y)
		box.bottom = pos.y;
		
	return box;
}

private function buildBucketGrid(): void
{
	_bucketGrid = [];
	
	var originLeft: Number = _worldBoundingBox.left;
	var originTop: Number = _worldBoundingBox.top;
	
	var columnWidth: Number = _worldBoundingBox.width/_bucketGridColumns;
	var rowHeight: Number = _worldBoundingBox.height/_bucketGridRows;
	
	for (var rowIndex: int = 0; rowIndex<_bucketGridRows; rowIndex+=1)
	{
		_bucketGrid[rowIndex] = [];
		
		var rowTop: Number = (originTop+(rowHeight*rowIndex));
		
		for (var columnIndex: int = 0; columnIndex<_bucketGridColumns; columnIndex+=1)
		{
			var columnLeft: Number = (originLeft+(columnWidth*columnIndex));
	
			var boundingBox: Rectangle = new Rectangle(columnLeft, rowTop, columnWidth, rowHeight);

			_bucketGrid[rowIndex][columnIndex] = {
				boundingBox: boundingBox,
				ways: []
			};
		}
	}
	
	for (var wayId:String in _ways)
	{
		var way: Object = _ways[wayId];

		boundingBox = way.boundingBox;
		if (boundingBox.isEmpty())
			continue;
		
		var leftIndex: int = Math.floor((boundingBox.left-originLeft)/columnWidth);
		var rightIndex: int = Math.floor((boundingBox.right-originLeft)/columnWidth);
		var topIndex: int = Math.floor((boundingBox.top-originTop)/rowHeight);
		var bottomIndex: int = Math.floor((boundingBox.bottom-originTop)/rowHeight);

		leftIndex = Math.max(leftIndex, 0);
		rightIndex = Math.min(rightIndex, (_bucketGridColumns-1));
		topIndex = Math.max(topIndex, 0);
		bottomIndex = Math.min(bottomIndex, (_bucketGridRows-1));

		for (rowIndex=topIndex; rowIndex<=bottomIndex; rowIndex+=1)
		{
			for (columnIndex=leftIndex; columnIndex<=rightIndex; columnIndex+=1)
			{
				_bucketGrid[rowIndex][columnIndex].ways.push(wayId);
			}
		}

	}
}

private function getWaysContainingLatLon(lat: Number, lon: Number): Array
{
	var result: Array = new Array();

	var pos: Point = new Point(lon, lat);

	if (!_worldBoundingBox.containsPoint(pos))
		return result;
	
	var originLeft: Number = _worldBoundingBox.left;
	var originTop: Number = _worldBoundingBox.top;
	
	var columnWidth: Number = _worldBoundingBox.width/_bucketGridColumns;
	var rowHeight: Number = _worldBoundingBox.height/_bucketGridRows;

	var columnIndex: int = Math.floor((pos.x-originLeft)/columnWidth);
	var rowIndex: int = Math.floor((pos.y-originTop)/rowHeight);
	
	var ways: Array = _bucketGrid[rowIndex][columnIndex].ways;

	var pixelsPerDegree: Number = getPixelsPerDegreeLatitude();
	var pixelsToDegreeScale: Number = (1.0/pixelsPerDegree);
	
	for each (var wayId: String in ways)
	{
		var way: Object = _ways[wayId];
		var isInside: Boolean = false;
		if (way.isClosed)
		{
			if (way.boundingBox.containsPoint(pos))
			{
				isInside = isPointInsideClosedWay(pos, way);
			}
		}
		else
		{
			var lineThickness: Number = (Number)(getWayProperty('line_thickness', way));
			
			var thicknessInDegrees: Number = Math.abs((lineThickness+1)*pixelsToDegreeScale);
			
			var boundingBox: Rectangle = way.boundingBox.clone();
//			boundingBox.inflate(thicknessInDegrees/2, thicknessInDegrees/2);
			
			if (boundingBox.containsPoint(pos))
			{
				isInside = isPointOnWayLine(pos, way, thicknessInDegrees);	
			}			
		}
		
		if (isInside)
		{
			var wayResult: Object = {};
			wayResult.id = wayId;
			wayResult.tags = {};
			
			for (var key: String in way.tags)
			{
				// Pete - Safari really doesn't like colons in member names! 
				key = key.replace(':', '_colon_');
				var value: String = way.tags[key];
				wayResult.tags[key] = value;
			}
			
			result.push(wayResult);
		}
	}
	
	return result;
}

private function addTimelineControls(): void
{
	_timelineControls = new TimelineControls();
	_timelineControls.percentWidth = 100;
	_timelineControls.setWidth(_width-200);
	
	var verticalCenter: Number = ((_height/2)-40);
	_timelineControls.setStyle("verticalCenter", verticalCenter);
	_timelineControls.setTimeTextStyle(12, 0x000000);
	
	_timelineControls.setOnUserInputCallback(onTimelineUserInput);

	addChild(this._timelineControls);
	
	updateTimelineDisplay();
}

private function onTimelineUserInput(dragging: Boolean): void
{
	var sliderValue: Number = _timelineControls.sliderValue;

	var totalFrames: int = _frameTimes.length;

	_frameIndex = Math.round(sliderValue*totalFrames);
	_frameIndex = Math.min(_frameIndex, (totalFrames-1));
	_frameIndex = Math.max(_frameIndex, 0);
	
	updateTimelineDisplay();
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
		
	_valuesDirty = true;
	onDataChange();
}

private function updateTimelineDisplay(): void
{
	var currentTime: String = _frameTimes[_frameIndex];
	_timelineControls.timeText = currentTime;
	
	var totalFrames: int = _frameTimes.length;
	_timelineControls.sliderValue = (_frameIndex/totalFrames);
}

private function getValueForWayId(wayId: String): String
{
	if (typeof _ways[wayId] === 'undefined')
		return null;
		
	var way: Object = _ways[wayId];

	if (_valueData === null)
		return null;

	var currentValues: Array;
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = _valueData[currentTime];
	}
	else
	{
		currentValues = _valueData;
	}
	
	var resultFound: Boolean = false;
	var result: String;
	for each (var values: Array in currentValues)
	{
		var matchKeys: Object = {};
		var thisValue: String = null;		
		for (var i:int = 0; i<values.length; i+=1)
		{
			if (i===_valueColumnIndex)
			{
				thisValue = values[i];
			}
			else if (i!==_timeColumnIndex)
			{
				var headerName: String = _valueHeaders[i];
				matchKeys[headerName] = values[i];	
			}
		}
		
		var allMatch: Boolean = true;
		for (var key: String in matchKeys)
		{
			var value:String = matchKeys[key];
			
			if (way.tags[key]!==value)
				allMatch = false;	
		}
		
		if (allMatch)
		{
			resultFound = true;
			result = thisValue;
		}
	}

	if (resultFound)
		return result;
	else
		return null;
}

private function addInlay(leftX: Number, topY: Number, rightX: Number, bottomY: Number, topLat: Number, leftLon: Number, bottomLat: Number, rightLon: Number): void
{
	var width: Number = (rightX-leftX);
	var height: Number = (bottomY-topY);
	
	var widthLon: Number = (rightLon-leftLon);
	var heightLat: Number = (bottomLat-topLat);
	
	var scaleX: Number = (width/widthLon);
	var scaleY: Number = (height/heightLat);

	var latLonToXYMatrix: Matrix = new Matrix();
	latLonToXYMatrix.translate(-leftLon, -topLat);
	latLonToXYMatrix.scale(scaleX, scaleY);	

	var xYToLatLonMatrix: Matrix = latLonToXYMatrix.clone();
	xYToLatLonMatrix.invert();
	
	var worldTopLeftLatLon: Object = getLatLonFromXY(new Point(leftX, topY), _xYToLatLonMatrix);
	var worldBottomRightLatLon: Object = getLatLonFromXY(new Point(rightX, bottomY), _xYToLatLonMatrix);
	
	_inlays.push({
		latLonToXYMatrix: latLonToXYMatrix,
		xYToLatLonMatrix: xYToLatLonMatrix,
		worldTopLeftLatLon: worldTopLeftLatLon,
		worldBottomRightLatLon: worldBottomRightLatLon
	});
}

private function cropPoint(input: Point, area: Rectangle): Point
{
	var result: Point = input.clone();
	
	if (result.x<area.left)
		result.x = area.left;
	
	if (result.x>area.right)
		result.x = area.right;	
	
	if (result.y<area.top)
		result.y = area.top;
	
	if (result.y>area.bottom)
		result.y = area.bottom;	

	return result;	
}

private function drawMapIntoMainBitmap(): void
{		
	doRedraw(_mainShape.graphics, _width, _height, _latLonToXYMatrix, _xYToLatLonMatrix);
			
	for each (var inlay: Object in _inlays)
	{
		var screenTopLeft: Point = getXYFromLatLon(inlay.worldTopLeftLatLon, _latLonToXYMatrix);
		var screenBottomRight: Point = getXYFromLatLon(inlay.worldBottomRightLatLon, _latLonToXYMatrix);
		
		var screenArea: Rectangle = new Rectangle(0, 0, _width, _height);
		
		var croppedScreenTopLeft: Point = cropPoint(screenTopLeft, screenArea);
		var croppedScreenBottomRight: Point = cropPoint(screenBottomRight, screenArea);
		
		var inlayWidth: Number = (croppedScreenBottomRight.x-croppedScreenTopLeft.x);
		var inlayHeight: Number = (croppedScreenBottomRight.y-croppedScreenTopLeft.y);
		
		if ((inlayWidth<1)||(inlayHeight<1))
			continue;
		
		var inlayScreenLeftX: Number = croppedScreenTopLeft.x;
		var inlayScreenTopY: Number = croppedScreenTopLeft.y;
		
		var localTopLeft: Point = croppedScreenTopLeft.subtract(screenTopLeft);

		var croppedLatLonToXYMatrix: Matrix = inlay.latLonToXYMatrix.clone();
		croppedLatLonToXYMatrix.translate(-localTopLeft.x, -localTopLeft.y);
		
		var croppedXYToLatLonMatrix: Matrix = croppedLatLonToXYMatrix.clone();
		croppedXYToLatLonMatrix.invert();
		
		var drawingSurface: Shape = new Shape();

		var bitmapData:BitmapData = new BitmapData(inlayWidth, inlayHeight, false, _oceanColor);
		
		doRedraw(drawingSurface.graphics, inlayWidth, inlayHeight, croppedLatLonToXYMatrix, croppedXYToLatLonMatrix);
		bitmapData.draw(drawingSurface, new Matrix());

		var inlayMatrix: Matrix = new Matrix();
		inlayMatrix.translate(inlayScreenLeftX, inlayScreenTopY);

		_mainShape.graphics.beginBitmapFill(bitmapData, inlayMatrix, false);
		_mainShape.graphics.drawRect(inlayScreenLeftX, inlayScreenTopY, inlayWidth, inlayHeight);
		_mainShape.graphics.endFill();
	}

	_mainBitmap.bitmapData.draw(_mainShape, new Matrix());
	
	_mainBitmapTopLeftLatLon = getLatLonFromXY(new Point(0, 0), _xYToLatLonMatrix);
	_mainBitmapBottomRightLatLon = getLatLonFromXY(new Point(_width, _height), _xYToLatLonMatrix);
}

private function drawMainBitmapIntoViewer(): void
{
	viewer.graphics.clear();
	
	if ((_mainBitmapTopLeftLatLon===null)||
		(_mainBitmapBottomRightLatLon===null))
		return;
		
	var screenBitmapTopLeft: Point = getXYFromLatLon(_mainBitmapTopLeftLatLon, _latLonToXYMatrix);
	var screenBitmapBottomRight: Point = getXYFromLatLon(_mainBitmapBottomRightLatLon, _latLonToXYMatrix);	

	var screenBitmapLeft: Number = screenBitmapTopLeft.x;
	var screenBitmapTop: Number = screenBitmapTopLeft.y;
	
	var screenBitmapWidth: Number = (screenBitmapBottomRight.x-screenBitmapTopLeft.x);
	var screenBitmapHeight: Number = (screenBitmapBottomRight.y-screenBitmapTopLeft.y);
	
	var bitmapTransform: Matrix = new Matrix();
	bitmapTransform.scale((screenBitmapWidth/_width), (screenBitmapHeight/_height));
	bitmapTransform.translate(screenBitmapLeft, screenBitmapTop);
	
	viewer.graphics.beginBitmapFill(_mainBitmap.bitmapData, bitmapTransform, false);
	viewer.graphics.drawRect(screenBitmapLeft, screenBitmapTop, screenBitmapWidth, screenBitmapHeight);
	viewer.graphics.endFill();	
}

private function translateMapByScreenPixels(x: Number, y: Number, dragging: Boolean = false): void
{
	_latLonToXYMatrix.translate(x, y);
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
}

private function zoomMapByFactorAroundPoint(zoomFactor: Number, center: Point, dragging: Boolean = false): void
{
	var translateToOrigin: Matrix = new Matrix();
	translateToOrigin.translate(-center.x, -center.y);
	
	var scale: Matrix = new Matrix();
	scale.scale(zoomFactor, zoomFactor);
	
	var translateFromOrigin: Matrix = new Matrix();
	translateFromOrigin.translate(center.x, center.y);

	var zoom: Matrix = new Matrix();
	zoom.concat(translateToOrigin);
	zoom.concat(scale);
	zoom.concat(translateFromOrigin);
	
	_latLonToXYMatrix.concat(zoom);
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();

	for each (var inlay: Object in _inlays)
	{
		var newLatLonToXYMatrix: Matrix = inlay.latLonToXYMatrix.clone();
		newLatLonToXYMatrix.concat(scale);
		
		var newXYToLatLonMatrix: Matrix = newLatLonToXYMatrix.clone();
		newXYToLatLonMatrix.invert();
		
		inlay.latLonToXYMatrix = newLatLonToXYMatrix;
		inlay.xYToLatLonMatrix = newXYToLatLonMatrix;
	}
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
		
	updateZoomSliderDisplay();
}

private function createViewerElements(): void
{
	_mainShape = new Shape();
	var bitmapData:BitmapData = new BitmapData(width, height, false, _oceanColor);
	_mainBitmap = new Bitmap(bitmapData);
	_mainBitmap.x = 0;
	_mainBitmap.y = 0;
	
	_zoomSlider = new VSlider();
	_zoomSlider.x = 4;
	_zoomSlider.y = 50;
	_zoomSlider.height = 150;
	_zoomSlider.showDataTip = false;
	_zoomSlider.minimum = 0;
	_zoomSlider.maximum = 1;
	_zoomSlider.liveDragging = true;

	_zoomSlider.addEventListener( SliderEvent.CHANGE, onZoomThumbDrag );
	_zoomSlider.addEventListener( SliderEvent.THUMB_DRAG, onZoomThumbDrag );
	_zoomSlider.addEventListener( SliderEvent.THUMB_RELEASE, onZoomThumbRelease );
	_zoomSlider.addEventListener( SliderEvent.THUMB_PRESS, onZoomThumbRelease );
	
	addChild(_zoomSlider);

	var plusImage: BitmapAsset = BitmapAsset( new PlusImage() );
	var minusImage: BitmapAsset = BitmapAsset( new MinusImage() );

	var blackTint:ColorTransform = new ColorTransform();
	blackTint.color = 0x000000;
	
	plusImage.x = 6;
	plusImage.y = 40;
	plusImage.transform.colorTransform = blackTint;
	viewer.addChild(plusImage);
	
	minusImage.x = 6;
	minusImage.y = 195;
	minusImage.transform.colorTransform = blackTint;
	viewer.addChild(minusImage);	
}

private function onZoomThumbDrag( event: SliderEvent ): void
{
	var pixelsPerDegreeLatitude: Number = calculatePixelsPerDegreeLatitudeFromZoomSlider();
	
	setPixelsPerDegreeLatitude(pixelsPerDegreeLatitude, true);
}

private function onZoomThumbRelease( event: SliderEvent ): void
{
	var pixelsPerDegreeLatitude: Number = calculatePixelsPerDegreeLatitudeFromZoomSlider();
	
	setPixelsPerDegreeLatitude(pixelsPerDegreeLatitude, false);	
}

private function getPixelsPerDegreeLatitude(): Number
{
	var pixelsPerDegreeLatitude: Number = _latLonToXYMatrix.d;
	
	return pixelsPerDegreeLatitude;
}

private function setPixelsPerDegreeLatitude(newPixelsPerDegreeLatitude: Number, dragging: Boolean = false): void
{
	var oldPixelsPerDegreeLatitude: Number = getPixelsPerDegreeLatitude();
	
	var zoomFactor: Number = (newPixelsPerDegreeLatitude/oldPixelsPerDegreeLatitude);
	
	var center: Point = new Point((_width/2), (_height/2));
	
	zoomMapByFactorAroundPoint(zoomFactor, center, dragging);
}

private function calculatePixelsPerDegreeLatitudeFromZoomSlider(): Number
{
	var sliderValue: Number = _zoomSlider.value;
	
	var lerpValue: Number = Math.pow(sliderValue, _zoomSliderPower);

	var minPixelsPerDegreeLatitude: Number = (_height/_zoomedOutDegreesPerPixel);
	var maxPixelsPerDegreeLatitude: Number = (_height/_zoomedInDegreesPerPixel);

	var oneMinusLerp: Number = (1-lerpValue);
	
	var result: Number = (minPixelsPerDegreeLatitude*oneMinusLerp)+
		(maxPixelsPerDegreeLatitude*lerpValue);
	
	return result;
}

private function updateZoomSliderDisplay(): void
{
	var pixelsPerDegreeLatitude: Number = getPixelsPerDegreeLatitude();

	var minPixelsPerDegreeLatitude: Number = (_height/_zoomedOutDegreesPerPixel);
	var maxPixelsPerDegreeLatitude: Number = (_height/_zoomedInDegreesPerPixel);

	var lerpValue: Number = ((pixelsPerDegreeLatitude-minPixelsPerDegreeLatitude)/
		(maxPixelsPerDegreeLatitude-minPixelsPerDegreeLatitude));
	
	var sliderValue: Number = Math.pow(lerpValue, (1/_zoomSliderPower));

	_zoomSlider.value = sliderValue;
}

private function setGradientValueRange(min: Number, max: Number): void
{
	_isGradientValueRangeSet = true;
	_gradientValueMin = min;
	_gradientValueMax = max;
}

private function calculateFrameTimes(): void
{
	_frameTimes = [];
	
	for (var thisTime: String in _foundTimes)
	{
		if ((_timeRangeStart!==null)&&(thisTime<_timeRangeStart))
			continue;

		if ((_timeRangeEnd!==null)&&(thisTime>_timeRangeEnd))
			continue;
		
		_frameTimes.push(thisTime);
	}
	_frameTimes.sort();
}

private function setTimeRange(timeStart: String, timeEnd: String): void
{
	_timeRangeStart = timeStart
	_timeRangeEnd = timeEnd;
	
	calculateFrameTimes();
}

private function onDataChange(): void
{
	if (_onDataChangeFunction!==null)
		ExternalInterface.call(_onDataChangeFunction, null);	
}

private function logError(message: String): void
{
	trace('Error: '+message);
	if (_onErrorFunction!==null)
		ExternalInterface.call(_onErrorFunction, message);	
}

private function getWayForWayId(wayId: String): Object
{
	var result: Object = _ways[wayId];
	
	trace('Found '+result);
	
	return result;	
}

private function isPointInsideClosedWay(pos: Point, way: Object): Boolean
{
	var xIntersections: Array = [];

	var lineStart: Point = null;
	var isFirst: Boolean = true;
	
	for each (var currentNd: String in way.nds)
	{
		var currentNode: Object = _nodes[currentNd];
		var lineEnd: Point = new Point(currentNode.lon, currentNode.lat);
		
		if (isFirst)
		{
			isFirst = false;
		}
		else
		{
			if (((lineStart.y>pos.y)&&(lineEnd.y<pos.y))||
				((lineStart.y<pos.y)&&(lineEnd.y>pos.y)))
			{
				var lineDirection: Point = new Point(lineEnd.x-lineStart.x, lineEnd.y-lineStart.y);
				var yDelta: Number = (pos.y-lineStart.y);
				var yProportion: Number = (yDelta/lineDirection.y);
				
				var xIntersect: Number = (lineStart.x+(lineDirection.x*yProportion));
				xIntersections.push(xIntersect);
			}
			
		}
		
		lineStart = lineEnd;
	}
	
	xIntersections.sort(function(a:Number, b:Number): int {
		if (a<b) return -1;
		else if (a>b) return 1;
		else return 0; 
	});
	
	var isInside: Boolean = false;
	for (var index: int = 0; index<(xIntersections.length-1); index += 2)
	{
		var leftX: Number = xIntersections[index];
		var rightX: Number = xIntersections[(index+1)];

		if ((leftX<=pos.x)&&(rightX>pos.x))
			isInside = true;
		
	}
				
	return isInside;
}

private function isPointOnWayLine(pos: Point, way: Object, thickness: Number): Boolean
{
	var lineStart: Point = null;
	var isFirst: Boolean = true;
	
	var thicknessSquared: Number = (thickness*thickness);
	
	var isInside: Boolean = false;
	for each (var currentNd: String in way.nds)
	{
		var currentNode: Object = _nodes[currentNd];
		var lineEnd: Point = new Point(currentNode.lon, currentNode.lat);
		
		if (isFirst)
		{
			isFirst = false;
		}
		else
		{
			var lineDirection: Point = new Point(lineEnd.x-lineStart.x, lineEnd.y-lineStart.y);
			
			var lineDirectionSquared: Number = ((lineDirection.x*lineDirection.x)+(lineDirection.y*lineDirection.y));
			
			var s: Number = ((pos.x-lineStart.x)*lineDirection.x)+((pos.y-lineStart.y)*lineDirection.y);
			s /= lineDirectionSquared;
			
			s = Math.max(s, 0);
			s = Math.min(s, 1);
			
			var closestPoint: Point = new Point((lineStart.x+s*lineDirection.x), (lineStart.y+s*lineDirection.y));
			
			var delta: Point = pos.subtract(closestPoint);
			
			var distanceSquared: Number = ((delta.x*delta.x)+(delta.y*delta.y));
			
			if (distanceSquared<thicknessSquared)
			{
				isInside = true;
				break;
			}
		}
		
		lineStart = lineEnd;
	}
	
				
	return isInside;
}

private function createBitmapBackground(width: Number, height: Number, viewingArea: Rectangle, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): BitmapData
{
	var bitmapWidth: Number = (width/_bitmapBackgroundResolution);
	var bitmapHeight: Number = (height/_bitmapBackgroundResolution);
	
	var result: BitmapData = new BitmapData(bitmapWidth, bitmapHeight, true, 0xffff00);
	
	var pixelData: ByteArray = new ByteArray();
	
	for (var y: int = 0; y<bitmapHeight; y+=1)
	{
		for (var x: int = 0; x<bitmapWidth; x+=1)
		{
			var color: uint;
			if ((x&1)^(y&1))
				color = 0xff000000;
			else
				color = 0xffffffff;
			
			pixelData.writeUnsignedInt(color);
		}	
	}
	
	pixelData.position = 0;
	
	result.setPixels(new Rectangle(0, 0, bitmapWidth, bitmapHeight), pixelData);
	
	return result;
}

private function loadAreaValues(linesArray: Array, headerLine: String, columnSeperator: String): void
{
	if (_valueColumnIndex===-1)
	{
		logError( 'Error loading CSV file "'+_valuesFileName+'" - missing value column from header "'+headerLine+'"');
		return;
	}
	
	_foundTimes = {};
	
	_valueData = [];
	
	for(var i : int = 1; i < linesArray.length; i++ )
	{
		var lineString: String = linesArray[i];
		var lineValues: Array = decodeCSVRow(lineString, columnSeperator);
		
		var thisValue: Number = (Number)(lineValues[_valueColumnIndex]);
		
		if ((i===1)||(thisValue<_smallestValue))
			_smallestValue = thisValue;
			
		if ((i===1)||(thisValue>_largestValue))
			_largestValue = thisValue;
		
		if (_hasTime)
		{
			var thisTime: String = lineValues[_timeColumnIndex];
			if (thisTime !== null)
			{
				if (typeof _foundTimes[thisTime] === 'undefined')
				{
					_foundTimes[thisTime] = true;
					_valueData[thisTime] = [];
				}
				
				_valueData[thisTime].push(lineValues);
			}
		}
		else
		{
			_valueData.push(lineValues);		
		}
		
	}
	
}

private function loadPointValues(linesArray: Array, headerLine: String, columnSeperator: String): void
{	
	_foundTimes = {};
	
	_valueData = [];
	
	for(var i : int = 1; i < linesArray.length; i++ )
	{
		var lineString: String = linesArray[i];
		var lineValues: Array = decodeCSVRow(lineString, columnSeperator);
		
		var thisLatitude: Number = (Number)(lineValues[_latitudeColumnIndex]);
		var thisLongitude: Number = (Number)(lineValues[_longitudeColumnIndex]);
		
		lineValues[_latitudeColumnIndex] = thisLatitude;
		lineValues[_longitudeColumnIndex] = thisLongitude;

		_valueData.push(lineValues);		
	}	
}

]]>
</mx:Script>
<mx:UIComponent id="viewer"></mx:UIComponent>
	
</mx:Application>
