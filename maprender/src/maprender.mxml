<?xml version="1.0" encoding="utf-8"?>

<!--
OpenGraphMap renderer - a flash component to display and explore map visualizations
Copyright (C) 2010 Pete Warden <pete@petewarden.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" 
    width="800" height="600" 
    applicationComplete="startup()">

<mx:Script>
<![CDATA[

import mx.controls.Label;
import flash.external.ExternalInterface; 
import mx.controls.Text;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import mx.controls.sliderClasses.Slider;
import mx.controls.VSlider;
import mx.core.BitmapAsset;
import mx.events.SliderEvent;
import flash.text.TextField;

import TimelineControls;
import BucketGrid;

public var _mainShape:Shape = null;
public var _mainBitmap: Bitmap = null;
public var _dirty: Boolean = true;
public var _redrawCountdown: int = 0;
public var _oceanColor: Number = 0xd0e0ff;

public var _wayDefaults: Object = {
	color: 0x000000,
	alpha: 1.0,
	line_thickness: 0
};

public var _colorGradient: Array = [
	{red: 0x00, green: 0xb0, blue: 0x00},
	{red: 0xe0, green: 0xe0, blue: 0x00},
	{red: 0xff, green: 0x00, blue: 0x00},
];

public var _highlightColor: Number = 0xff0000;

public var _onClickFunction: String = null;
public var _onDoubleClickFunction: String = null;
public var _onMouseDownFunction: String = null;
public var _onMouseUpFunction: String = null;
public var _onMouseOverFunction: String = null;
public var _onMouseOutFunction: String = null;
public var _onMouseMoveFunction: String = null;
public var _onFrameRenderFunction: String = null;
public var _onDataChangeFunction: String = null;
public var _onWaysLoadFunction: String = null;
public var _onValuesLoadFunction: String = null;
public var _onErrorFunction: String = null;

public var _nodes: Object = {};
public var _ways: Object = {};

public var _waysLoader: URLLoader;
public var _waysFileName: String = "";

public var _valuesLoader: URLLoader;
public var _valuesFileName: String = "";

public var _valueHeaders: Array = null;
public var _valueData: Array = null;
public var _timeColumnIndex: int;
public var _valueColumnIndex: int;

public var _smallestValue: Number;
public var _largestValue: Number;

public var _hasTime: Boolean = false;
public var _frameTimes: Array = [];
public var _frameIndex: Number = 0;

public var _tagMap: Object = {};

public var _latLonToXYMatrix: Matrix = new Matrix();
public var _xYToLatLonMatrix: Matrix = new Matrix();

public var _worldBoundingBox: Rectangle = new Rectangle();
public var _waysGrid: BucketGrid = null;

public var _timelineControls: TimelineControls = null;

public var _inlays: Array = [];

public var _valuesDirty: Boolean = false;

public var _mainBitmapTopLeftLatLon: Object = null;
public var _mainBitmapBottomRightLatLon: Object = null;

public var _isDragging: Boolean = false;
public var _lastDragPosition: Point = null;
public var _lastClickTime: Number = 0;

public var _zoomSlider: Slider = null;
[Embed(source="images/plus.gif")]
public var PlusImage:Class;
[Embed(source="images/minus.gif")]
public var MinusImage:Class;

public var _foundTimes: Object = {};

public var _hasBitmapBackground: Boolean = false;
public var _bitmapBackgroundResolution: int = 2;

public var _hasPointValues: Boolean = false;
public var _latitudeColumnIndex: int = -1;
public var _longitudeColumnIndex: int = -1;

public var _pointsGrid: BucketGrid = null;

public var _settings: Object =
{
	width: 800,
	height: 600,
	zoom_slider_power: 5.0,
	zoomed_out_degrees_per_pixel: -180,
	zoomed_in_degrees_per_pixel: -0.01,
	is_gradient_value_range_set: false,
	gradient_value_min: 0,
	gradient_value_max: 0,
	point_blob_radius: 0.001,
	point_blob_value: 1.0,
	credit_text: '<a href="http://openheatmap.com"><u>OpenHeatMap</u></a>',
	credit_color: '0x303030',
	title_text: '',
	title_size: 15,
	title_color: '0x000000',
	title_background_color: '0xd0e0ff',
	title_background_alpha: 1.0,
	time_range_start: null,
	time_range_end: null,
    force_outlines: false
};

public var _lastSetWayIds: Object = {};

public var _credit: Label = null;
public var _title: TextField = null;

private function getURLInput(name: String, defaultValue: String = null): String
{
	if (mx.core.Application.application.parameters.hasOwnProperty(name))
		return mx.core.Application.application.parameters[name];
	else
		return defaultValue;
}
	
public function startup():void
{
	flash.system.Security.allowDomain("*");

	setSize(800, 600);

	createViewerElements();

	setLatLonViewingArea(90, -180, -90, 180);
		    
    viewer.addEventListener( MouseEvent.CLICK, mapMouseClickHandler );
	// Pete- I'm synthesizing double-click events, see the single click handler for details
//    viewer.addEventListener( MouseEvent.DOUBLE_CLICK, mapMouseDoubleClickHandler );
    viewer.addEventListener( MouseEvent.MOUSE_DOWN, mapMouseDownHandler );
    viewer.addEventListener( MouseEvent.MOUSE_MOVE, mapMouseMoveHandler );
    viewer.addEventListener( MouseEvent.MOUSE_OUT, mapMouseOutHandler );
    viewer.addEventListener( MouseEvent.MOUSE_OVER, mapMouseOverHandler );
    viewer.addEventListener( MouseEvent.MOUSE_UP, mapMouseUpHandler );
//    viewer.addEventListener( MouseEvent.MOUSE_WHEEL, mapMouseWheelHandler );
//	viewer.doubleClickEnabled = true;

	_dirty = true;

	addEventListener(Event.ENTER_FRAME, doEveryFrame);
	
	ExternalInterface.addCallback("setSize", setSize);      	
	ExternalInterface.addCallback("setLatLonViewingArea", setLatLonViewingArea);      	
	ExternalInterface.addCallback("setOceanColor", function(color: Number): void { _oceanColor = color; _dirty = true; });
	ExternalInterface.addCallback("setWayDefault", setWayDefault);
	ExternalInterface.addCallback('setEventHandler', setEventHandler);
	ExternalInterface.addCallback("loadWaysFromFile", loadWaysFromFile);      	
	ExternalInterface.addCallback("loadValuesFromFile", loadValuesFromFile);
	ExternalInterface.addCallback("setColorGradient", setColorGradient);	
	ExternalInterface.addCallback("getWaysContainingLatLon", getWaysContainingLatLon);
	ExternalInterface.addCallback("getValueForWayId", getValueForWayId);
	ExternalInterface.addCallback("addInlay", addInlay);
	ExternalInterface.addCallback("translateMapByScreenPixels", translateMapByScreenPixels);
	ExternalInterface.addCallback("zoomMapByFactorAroundPoint", zoomMapByFactorAroundPoint);
	ExternalInterface.addCallback("getPixelsPerDegreeLatitude", getPixelsPerDegreeLatitude);
	ExternalInterface.addCallback("setPixelsPerDegreeLatitude", setPixelsPerDegreeLatitude);
	ExternalInterface.addCallback("setGradientValueRange", setGradientValueRange);
	ExternalInterface.addCallback("getWayForWayId", getWayForWayId);
	ExternalInterface.addCallback("getValuePointsNearLatLon", getValuePointsNearLatLon);
	ExternalInterface.addCallback("loadValuesFromCSVString", loadValuesFromCSVString);
	ExternalInterface.addCallback("setSetting", setSetting);
	ExternalInterface.addCallback("getLatLonViewingArea", getLatLonViewingArea);
	ExternalInterface.addCallback("removeAllInlays", removeAllInlays);
	ExternalInterface.addCallback("removeAllWays", removeAllWays);

	var onLoadFunction: String = getURLInput('onload', 'onMapCreated');
	if (onLoadFunction !== null)
		ExternalInterface.call(onLoadFunction, '');
}

private function setWayDefault(propertyName: String, propertyValue: Object): void
{
	_wayDefaults[propertyName] = propertyValue;
	_dirty = true;
}

private function getWayProperty(propertyName: String, wayInfo: Object = null): Object
{
	if ((wayInfo !== null) && (wayInfo.hasOwnProperty(propertyName)))
		return wayInfo[propertyName];
	else if (_wayDefaults.hasOwnProperty(propertyName))
		return _wayDefaults[propertyName];
	else
		return null;
}

private function doTagsMatch(tags: Array, lineInfo: Object): Boolean
{
	var result: Boolean = false;
	if (tags === null)
	{
		result = true;
	}
	else
	{
		if (lineInfo.hasOwnProperty('tags'))
		{
			var myTags: Array = lineInfo.tags;
			
			for each (var myTag: String in myTags)
			{
				for each (var tag: String in tags)
				{
					if (myTag === tag)
						result = true;
				}
			}
			
		}
	}
		
	return result;
}

private function getTagsFromArgument(tagsArgument: Object): Array
{
	if (tagsArgument === null)
		return null;
		
	if (tagsArgument is Array)
		return tagsArgument as Array;
	else
		return [ tagsArgument ];
}

private function setEventHandler(eventName: String, functionName: String): void
{
	eventName = eventName.toLowerCase();
	
	if (eventName == 'click')
		_onClickFunction = functionName;
	else if (eventName == 'doubleclick')
		_onDoubleClickFunction = functionName;
	else if (eventName == 'mousedown')
		_onMouseDownFunction = functionName;
	else if (eventName == 'mouseup')
		_onMouseUpFunction = functionName;
	else if (eventName == 'mouseover')
		_onMouseOverFunction = functionName;
	else if (eventName == 'mouseout')
		_onMouseOutFunction = functionName;
	else if (eventName == 'mousemove')
		_onMouseMoveFunction = functionName;
	else if (eventName == 'framerender')
		_onFrameRenderFunction = functionName;
	else if (eventName == 'datachange')
		_onDataChangeFunction = functionName;
	else if (eventName == 'waysload')
		_onWaysLoadFunction = functionName;
	else if (eventName == 'valuesload')
		_onValuesLoadFunction = functionName;
	else if (eventName == 'error')
		_onErrorFunction = functionName;
	else
		logError( 'Unknown event name passed to MapRender::setEventHandler - "'+
			eventName+'" (expected click, doubleclick, mousedown, mouseup, mouseover, mouseout, framerender, datachange, waysload, valuesload or error)');
}

private function setSize(width: Number, height: Number): void
{
	this.width = width;
	this.height = height;
	
	_settings.width = width;
	_settings.height = height;
	
//	if (_timelineControls !== null)
//		_timelineControls.setWidth(width);

	var bitmapData:BitmapData = new BitmapData(width, height, false, _oceanColor);
	_mainBitmap = new Bitmap(bitmapData);
	_mainBitmap.x = 0;
	_mainBitmap.y = 0;

	repositionMoveableElements();
	
	_dirty = true;	
}

private function setLatLonViewingArea(topLat: Number, leftLon: Number, bottomLat: Number, rightLon: Number): void
{
	var widthLon: Number = (rightLon-leftLon);
	var heightLat: Number = (bottomLat-topLat);
	
	var scaleX: Number = (_settings.width/widthLon);
	var scaleY: Number = (_settings.height/heightLat);

	var newMatrix: Matrix = new Matrix();
	newMatrix.translate(-leftLon, -topLat);
	newMatrix.scale(scaleX, scaleY);

	setLatLonToXYMatrix(newMatrix);
}

private function setLatLonToXYMatrix(newMatrix: Matrix): void
{
	_latLonToXYMatrix = newMatrix;
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();
	
	updateZoomSliderDisplay();
}

private function getXYFromLatLon(latLon: Object, latLonToXYMatrix: Matrix): Point
{
	var latLonPoint: Point = new Point(latLon.lon, latLon.lat);
	
	var result: Point = latLonToXYMatrix.transformPoint(latLonPoint);

	return result;
}

private function getLatLonFromXY(xYPoint: Point, xYToLatLonMatrix: Matrix): Object
{
	var latLonPoint: Point = xYToLatLonMatrix.transformPoint(xYPoint);
	
	var result: Object = {
			lat: latLonPoint.y,
			lon: latLonPoint.x
	}
	
	return result;
}

private function makeEventArgument(event:MouseEvent): Object
{
	var mouseX: Number = event.stageX;
	var mouseY: Number = event.stageY;

	var mainLatLon: Object = getLatLonFromXY(new Point(mouseX, mouseY), _xYToLatLonMatrix);
	
	var mouseLatLon: Object = null;
	for each (var inlay: Object in _inlays)
	{
		var screenTopLeft: Point = getXYFromLatLon(inlay.worldTopLeftLatLon, _latLonToXYMatrix);
		var screenBottomRight: Point = getXYFromLatLon(inlay.worldBottomRightLatLon, _latLonToXYMatrix);

		if ((mouseX>=screenTopLeft.x)&&
			(mouseX<screenBottomRight.x)&&
			(mouseY>=screenTopLeft.y)&&
			(mouseY<screenBottomRight.y))
		{
			var localX: Number = (mouseX-screenTopLeft.x);
			var localY: Number = (mouseY-screenTopLeft.y);
			mouseLatLon = getLatLonFromXY(new Point(localX, localY), inlay.xYToLatLonMatrix);
		}
	}
	
	if (mouseLatLon === null)
		mouseLatLon = mainLatLon;
	
	var mapPointData:Object = new Object();
	mapPointData.lon = mouseLatLon.lon;
	mapPointData.lat = mouseLatLon.lat;
	mapPointData.x = mouseX;
	mapPointData.y = mouseY;

	return mapPointData;
}
	
private function mapMouseClickHandler( event:MouseEvent ): Boolean
{
	var continueHandling: Boolean;
	if (_onClickFunction !== null)
		continueHandling = ExternalInterface.call(_onClickFunction, makeEventArgument(event));
	else
		continueHandling = true;

	// Pete - I can't get double-click events to fire reliably, so I've hard-coded an interval within which the
	// second normal click event triggers the double-click handler. Ugh, I feel dirty...
	var currentTime: Number = new Date().getTime();
	var sinceLastClick: Number = (currentTime-_lastClickTime);
	if (sinceLastClick<750)
	{
		mapMouseDoubleClickHandler(event);
		_lastClickTime = 0;
	}
	else
	{
		_lastClickTime = currentTime;	
	}
		
	return true;
}

private function mapMouseDoubleClickHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onDoubleClickFunction !== null)
		continueHandling = ExternalInterface.call(_onDoubleClickFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	if (continueHandling)
	{
		var center: Point = new Point(event.localX, event.localY);
		var zoomFactor: Number = 2.0;
		
		zoomMapByFactorAroundPoint(zoomFactor, center);
	}
		
	return true;
}

private function mapMouseDownHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseDownFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseDownFunction, makeEventArgument(event));
	else
		continueHandling = true;
	
	if (continueHandling)
	{
		var mousePosition: Point = new Point(event.localX, event.localY);

		_isDragging = true;
		_lastDragPosition = mousePosition; 
	}
	
	return true;
}

private function mapMouseUpHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseUpFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseUpFunction, makeEventArgument(event));
	else
		continueHandling = true;
	
	if (continueHandling)
	{
		if (_isDragging)
		{
			var mousePosition: Point = new Point(event.localX, event.localY);
	
			var positionChange: Point = mousePosition.subtract(_lastDragPosition);
	
			translateMapByScreenPixels(positionChange.x, positionChange.y, false);
	
			_isDragging = false;
		}
	}
	
	return true;
}

private function mapMouseOverHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseOverFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseOverFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	return true;
}

private function mapMouseOutHandler( event:MouseEvent ): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseOutFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseOutFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	return true;
}

private function mapMouseMoveHandler( event:MouseEvent): Boolean
{ 
	var continueHandling: Boolean;
	if (_onMouseMoveFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseMoveFunction, makeEventArgument(event));
	else
		continueHandling = true;

	if (continueHandling)
	{
		if (_isDragging)
		{
			var mousePosition: Point = new Point(event.localX, event.localY);
	
			var positionChange: Point = mousePosition.subtract(_lastDragPosition);
	
			translateMapByScreenPixels(positionChange.x, positionChange.y, true);
	
			_lastDragPosition = mousePosition;
		}
	}
			
	return true;
}

private function doEveryFrame(event: Event): void
{		
	if (_redrawCountdown>0)
	{
		_redrawCountdown -= 1;
		if (_redrawCountdown===0)
			_dirty = true;
	}
	
	if (_valuesDirty&&(_redrawCountdown===0))
	{
		if (!_hasPointValues)
			setWaysFromValues();
		_valuesDirty = false;		
	}
	
	if (_dirty)
	{		
		drawMapIntoMainBitmap();
				
		_dirty = false;
		_redrawCountdown = 0;
	}
	
	drawMainBitmapIntoViewer();
	
	if (_hasTime)
	{
		if (_timelineControls.isPlaying)
		{
			_frameIndex += 1;
			if (_frameIndex>=_frameTimes.length)
			{
				_frameIndex = (_frameTimes.length-1);
				_timelineControls.isPlaying = false;
			}
			
			updateTimelineDisplay();
			
			_dirty = true;
			_valuesDirty = true;
			onDataChange();
		}
	}

	if (_onFrameRenderFunction !== null)
		ExternalInterface.call(_onFrameRenderFunction, null);	
}

private function blankWay(): Object
{
	var result: Object = {};
	
	result.boundingBox = new Rectangle();
	result.nds = [];
	result.tags = {};
	result.isClosed = false;
	
	for each (var key:String in _wayDefaults)
	{
		result[key] = _wayDefaults[key];
	}

	return result;	
}

private function onWaysLoad(success:Boolean): void
{ 	  		  	
	var waysData:XML = XML(_waysLoader.data);
  	
  	_tagMap = {};
  	
  	for each (var node: * in waysData..node)
  	{
  		var newNode: Object = {
  				'lon': (Number)(node.@lon),
  				'lat': (Number)(node.@lat)
  		};
  		
  		_nodes[node.@id] = newNode;  		
  	}

  	for each (var way: * in waysData..way)
  	{
		var wayId: String = (String)(way.@id);

  		var newWay: Object = blankWay();
		newWay.id = wayId;
//		newWay.boundingBox = way.bound.@box.explode(',');

		var ndCount: Number = 0;
		var firstNd: String = null;
		var lastNd: String = null;
	  	for each (var nd: * in way..nd)
	  	{
	  		if (typeof _nodes[nd.@ref] === 'undefined')
	  			continue;

	  		ndCount += 1;
	  		newWay.nds.push(nd.@ref);
	  		
	  		if (firstNd===null)
	  			firstNd = nd.@ref;
	  		lastNd = nd.@ref;
	  			  			
	  		var thisNode: Object = _nodes[nd.@ref];
	  		var nodePos: Point = new Point(thisNode.lon, thisNode.lat);
	  		newWay.boundingBox = enlargeBoxToContain(newWay.boundingBox, nodePos);
	  	}
	  	
	  	newWay.isClosed = ((firstNd===lastNd)&&(!_settings.force_outlines));
	  	
	  	for each (var tag: * in way..tag)
	  	{
	  		var key: String = tag.@k;
	  		var value: String = tag.@v;
	  		
	  		newWay.tags[key] = value;
	  		
	  		if (typeof _tagMap[key] === 'undefined')
	  			_tagMap[key] = {};
	  			
	  		if (typeof _tagMap[key][value] === 'undefined')
	  			_tagMap[key][value] = [];
	  			
	  		_tagMap[key][value].push(newWay.id);
	  	}
  		
  		_ways[wayId] = newWay;
  		
  		if (!newWay.boundingBox.isEmpty())
  		{
  			_worldBoundingBox = enlargeBoxToContain(_worldBoundingBox, newWay.boundingBox.topLeft);
  			_worldBoundingBox = enlargeBoxToContain(_worldBoundingBox, newWay.boundingBox.bottomRight);
  		}
  	}

	buildWaysGrid();
	_dirty = true;
	_valuesDirty = true;
	if (_onWaysLoadFunction!==null)
		ExternalInterface.call(_onWaysLoadFunction, _waysFileName);
}
 	  
private function loadWaysFromFile(waysFileName: String): void
{
 	_waysFileName = waysFileName;
    _waysLoader = new URLLoader(new URLRequest(waysFileName));
    _waysLoader.addEventListener("complete", onWaysLoad);
}

private function decodeCSVRow(line: String, columnSeperator: String = ',') : Array
{
	var inQuotes: Boolean = false;
	var inEscape: Boolean = false;
	
	var result: Array = [];

	var currentValue: String = '';

	for( var i: int = 0; i < line.length; i+=1)
	{
		var currentChar: String = line.charAt(i);
	
		if (!inQuotes)
		{
			if (currentChar==='"')
			{
				inQuotes = true;
			}
			else if (currentChar===columnSeperator)
			{
				result.push(currentValue);
				currentValue = '';
			}
			else
			{
				currentValue += currentChar;
			}
		}
		else
		{
			if (!inEscape)
			{
				if (currentChar==='\\')
				{
					inEscape = true;
				}
				else if (currentChar==='"')
				{
					inQuotes = false;
				}
				else
				{
					currentValue += currentChar;
				}
				
			}
			else
			{
				currentValue += currentChar;
				inEscape = false;
			}
			
		}
		
	}
	
	result.push(currentValue);
	
	return result;
}

private function onValuesLoad(success:Boolean): void
{
	loadValuesFromCSVString(_valuesLoader.data.toString());

	if (_onValuesLoadFunction!==null)
		ExternalInterface.call(_onValuesLoadFunction, _valuesFileName);
}

private function loadValuesFromCSVString(valuesString: String): void
{
	var lineSeperator: String = '\n';
	var columnSeperator: String = ',';		  	

	var linesArray: Array = valuesString.split(lineSeperator);
	
	var headerLine: String = linesArray[0];

	_valueHeaders = decodeCSVRow(headerLine, columnSeperator);

	_timeColumnIndex = -1;
	_valueColumnIndex = -1;
	_latitudeColumnIndex = -1;
	_longitudeColumnIndex = -1;
	for(var headerIndex:int = 0; headerIndex < _valueHeaders.length; headerIndex++ )
	{
		var header: String = _valueHeaders[headerIndex].toLowerCase();
		if (header==='time')
			_timeColumnIndex = headerIndex;	
		else if (header==='value')
			_valueColumnIndex = headerIndex;
		else if ((header==='latitude')||(header==='lat'))
			_latitudeColumnIndex = headerIndex;
		else if ((header==='longitude')||(header==='lon'))
			_longitudeColumnIndex = headerIndex;
	}
	
	var hasLatitude: Boolean = (_latitudeColumnIndex!==-1);
	var hasLongitude: Boolean = (_longitudeColumnIndex!==-1);
	
	if ((hasLatitude||hasLongitude)&&(hasLatitude!=hasLongitude))
	{
		logError( 'Error loading CSV file "'+_valuesFileName+'" - only found one of longitude or latitude in "'+headerLine+'"');
		return;		
	}
	
	_hasPointValues = hasLatitude;
	_hasTime = (_timeColumnIndex!==-1);
	
	_hasBitmapBackground = _hasPointValues;
	
	if (!_hasPointValues)
		loadAreaValues(linesArray, headerLine, columnSeperator);
	else
		loadPointValues(linesArray, headerLine, columnSeperator);
		
	if (_hasTime)
	{
		calculateFrameTimes();
		_frameIndex = 0;
		addTimelineControls();
	}
	
	_valuesDirty = true;
	_dirty = true;			
}
private function loadValuesFromFile(valuesFileName: String): void
{
	_valuesFileName = valuesFileName;
	_valuesLoader = new URLLoader(new URLRequest(valuesFileName));
	_valuesLoader.addEventListener("complete", onValuesLoad);
}

private function doRedraw(graphics: Graphics, width: Number, height: Number, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): void
{		
	graphics.clear();

	graphics.beginFill(_oceanColor, 1.0);
   	graphics.drawRect(0, 0, width, height);
    graphics.endFill();
    
	var viewingArea: Rectangle = new Rectangle();
	
	var topLeftScreen: Point = new Point(0, 0);
	var bottomRightScreen: Point = new Point(width, height);
		
	var topLeftLatLon: Object = getLatLonFromXY(topLeftScreen, xYToLatLonMatrix);
	var bottomRightLatLon: Object = getLatLonFromXY(bottomRightScreen, xYToLatLonMatrix);
	
	viewingArea = enlargeBoxToContain(viewingArea, new Point(topLeftLatLon.lon, topLeftLatLon.lat));
	viewingArea = enlargeBoxToContain(viewingArea, new Point(bottomRightLatLon.lon, bottomRightLatLon.lat));	

    var bitmapBackground: BitmapData = createBitmapBackground(width, height, viewingArea, latLonToXYMatrix, xYToLatLonMatrix);

	drawWays(graphics, viewingArea, latLonToXYMatrix, bitmapBackground);
}

private function drawWays(graphics: Graphics, viewingArea: Rectangle, latLonToXYMatrix: Matrix, bitmapBackground: BitmapData): void
{
	var hasBitmap: Boolean = (bitmapBackground!==null);
	var bitmapMatrix: Matrix = new Matrix();
	bitmapMatrix.scale(_bitmapBackgroundResolution, _bitmapBackgroundResolution);
	
	for (var wayId:String in _ways)
	{
		var way: Object = _ways[wayId];
		var wayColor: Number;
		var wayAlpha: Number;
		if (getWayProperty('highlighted', way)==true)
		{
			wayColor = Number(getWayProperty('highlightColor', way));
			wayAlpha = Number(getWayProperty('highlightAlpha', way));
		}
		else
		{
			wayColor = Number(getWayProperty('color', way));
			wayAlpha = Number(getWayProperty('alpha', way));
		}

		if (way.nds.length<1)
			continue;
		
		if (!viewingArea.intersects(way.boundingBox))
			continue;

		var isClosed: Boolean = way.isClosed;

		if (isClosed)
		{		
			var finalNd: String = way.nds[way.nds.length-1];
			var finalNode: Object = _nodes[finalNd];
			
			var finalPos: Point = getXYFromLatLon(finalNode, latLonToXYMatrix);

			graphics.lineStyle();
			if (hasBitmap)
				graphics.beginBitmapFill(bitmapBackground, bitmapMatrix, false, true);
			else
				graphics.beginFill(wayColor, wayAlpha);
			
			graphics.moveTo(finalPos.x, finalPos.y);
		}
		else
		{
			var firstNd: String = way.nds[0];
			var firstNode: Object = _nodes[firstNd];
			
			var firstPos: Point = getXYFromLatLon(firstNode, latLonToXYMatrix);

			graphics.lineStyle(0, wayColor,wayAlpha);

			graphics.moveTo(firstPos.x, firstPos.y);
		}

		for each (var currentNd: String in way.nds)
		{
			var currentNode: Object = _nodes[currentNd];
			var currentPos: Point = getXYFromLatLon(currentNode, latLonToXYMatrix);
			
			graphics.lineTo(currentPos.x, currentPos.y);
		}

		if (isClosed)
		{
			graphics.endFill();
		}
	}

}

private function setWaysFromValues(): void
{
	if (_valueData === null)
		return;

	if (_settings.is_gradient_value_range_set)
	{
		var minValue: Number = _settings.gradient_value_min;
		var maxValue: Number = _settings.gradient_value_max;	
	}
	else
	{
		minValue = _smallestValue;
		maxValue = _largestValue;
	}
	var valueScale: Number = (1/(maxValue-minValue));

	var currentValues: Array;
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = _valueData[currentTime];
	}
	else
	{
		currentValues = _valueData;
	}
	
	var thisSetWayIds: Object = {};
	
	for each (var values: Array in currentValues)
	{
		if (_hasTime)
		{
			var thisTime: String = values[_timeColumnIndex];
			if (thisTime !== currentTime)
				continue;
		}

		var matchKeys: Object = {};
		var thisValue: Number = 0;		
		for (var i:int = 0; i<values.length; i+=1)
		{
			if (i===_valueColumnIndex)
			{
				thisValue = (Number)(values[i]);
			}
			else if (i!==_timeColumnIndex)
			{
				var headerName: String = _valueHeaders[i];
				matchKeys[headerName] = values[i];	
			}
		}
		
		var setColor: Number = getColorForValue(thisValue, minValue, maxValue, valueScale);
		
		setAttributeForMatchingWays(matchKeys, 'color', (String)(setColor), thisSetWayIds);
	}
	
	var defaultColor: String = (String)(getWayProperty('color'));
	
	for (var lastWayId: String in _lastSetWayIds)
	{
		if (thisSetWayIds.hasOwnProperty(lastWayId))
			continue;
			
		_ways[lastWayId]['color'] = defaultColor;
	}
	
	_lastSetWayIds = thisSetWayIds;
}

private function setColorGradient(colorList: Array) : void
{
	_colorGradient = [];
	
	for each (var colorString: String in colorList)
	{
		colorString = colorString.replace('#', '0x');
		
		var colorNumber: Number = (Number)(colorString);
		var red: Number = (colorNumber&0xff0000)>>16;
		var green: Number = (colorNumber&0x00ff00)>>8;
		var blue: Number = (colorNumber&0x0000ff)>>0;
		
		_colorGradient.push({
			red: red,
			green: green,
			blue: blue
		});
	}

	_valuesDirty = true;
	_redrawCountdown = 5;
}

private function setAttributeForMatchingWays(matchKeys: Object, attributeName: String, attributeValue: String, setWays: Object) : void
{
	var matchingWayIds: Object = null;
	for (var key:String in matchKeys)
	{
		var value: String = matchKeys[key];
		
		var currentMatches: Array;
		if (!_tagMap.hasOwnProperty(key)||!_tagMap[key].hasOwnProperty(value))
			currentMatches = [];
		else
		 	currentMatches = _tagMap[key][value];
		 
		if (matchingWayIds === null)
		{
			matchingWayIds = {};
			for each (var wayId: String in currentMatches)
				matchingWayIds[wayId] = true;
		}
		else
		{
			var previousMatchingWayIds: Object = matchingWayIds;
			matchingWayIds = {};
			for each (wayId in currentMatches)
			{
				if (typeof previousMatchingWayIds[wayId] !== 'undefined')
					matchingWayIds[wayId] = true;
			}
		}
	}
		
	var foundCount: Number = 0;
	for (wayId in matchingWayIds)
	{
		_ways[wayId][attributeName] = attributeValue;
		foundCount += 1;
		setWays[wayId] = true;
	}

//	if (foundCount===0)
//	{
//		trace('No match found for');
//		for (key in matchKeys)
//		{
//			value = matchKeys[key];	
//			trace(key+':'+value);
//		}
//	}

}

private function enlargeBoxToContain(box: Rectangle, pos: Point): Rectangle
{
	if (box.containsPoint(pos))
		return box;
	
	if ((box.x==0)&&
		(box.y==0)&&
		(box.width==0)&&
		(box.height==0))
		return new Rectangle(pos.x, pos.y, 0, 0);
		
	if (box.left>pos.x)
		box.left = pos.x;

	if (box.right<pos.x)
		box.right = pos.x;

	if (box.top>pos.y)
		box.top = pos.y;
		
	if (box.bottom<pos.y)
		box.bottom = pos.y;
		
	return box;
}

private function buildWaysGrid(): void
{
	_waysGrid = new BucketGrid(_worldBoundingBox, 16, 16);
	
	for (var wayId:String in _ways)
	{
		var way: Object = _ways[wayId];

		var boundingBox: Rectangle = way.boundingBox;
		if (boundingBox.isEmpty())
			continue;
		
		_waysGrid.insertObjectAt(boundingBox, wayId);
	}
}

private function getWaysContainingLatLon(lat: Number, lon: Number): Array
{
	var result: Array = new Array();

	var pos: Point = new Point(lon, lat);

	if (!_worldBoundingBox.containsPoint(pos))
		return result;
	
	if (_waysGrid===null)
		return result;
	
	var pixelsPerDegree: Number = getPixelsPerDegreeLatitude();
	var pixelsToDegreeScale: Number = (1.0/pixelsPerDegree);
	var ways: Array = _waysGrid.getContentsAtPoint(pos);
	
	for each (var wayId: String in ways)
	{
		var way: Object = _ways[wayId];
		var isInside: Boolean = false;
		if (way.isClosed)
		{
			if (way.boundingBox.containsPoint(pos))
			{
				isInside = isPointInsideClosedWay(pos, way);
			}
		}
		else
		{
			var lineThickness: Number = (Number)(getWayProperty('line_thickness', way));
			
			var thicknessInDegrees: Number = Math.abs((lineThickness+1)*pixelsToDegreeScale);
			
			var boundingBox: Rectangle = way.boundingBox.clone();
//			boundingBox.inflate(thicknessInDegrees/2, thicknessInDegrees/2);
			
			if (boundingBox.containsPoint(pos))
			{
				isInside = isPointOnWayLine(pos, way, thicknessInDegrees);	
			}			
		}
		
		if (isInside)
		{
			var wayResult: Object = {};
			wayResult.id = wayId;
			wayResult.tags = {};
			
			for (var key: String in way.tags)
			{
				// Pete - Safari really doesn't like colons in member names! 
				key = key.replace(':', '_colon_');
				var value: String = way.tags[key];
				wayResult.tags[key] = value;
			}
			
			result.push(wayResult);
		}
	}
	
	return result;
}

private function addTimelineControls(): void
{
	if (_timelineControls === null)
	{
		_timelineControls = new TimelineControls();
		_timelineControls.percentWidth = 100;
		_timelineControls.setWidth(_settings.width-250);
		
		var verticalCenter: Number = ((_settings.height/2)-40);
		_timelineControls.y = (_settings.height-50);
	
		_timelineControls.setTimeTextStyle(12, 0x000000);
		
		_timelineControls.setOnUserInputCallback(onTimelineUserInput);
	
		addChild(this._timelineControls);
	}
	
	updateTimelineDisplay();
}

private function onTimelineUserInput(dragging: Boolean): void
{
	var sliderValue: Number = _timelineControls.sliderValue;

	var totalFrames: int = _frameTimes.length;

	_frameIndex = Math.round(sliderValue*totalFrames);
	_frameIndex = Math.min(_frameIndex, (totalFrames-1));
	_frameIndex = Math.max(_frameIndex, 0);
	
	updateTimelineDisplay();
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
		
	_valuesDirty = true;
	onDataChange();
}

private function updateTimelineDisplay(): void
{
	if (_frameTimes.length>0)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		_timelineControls.timeText = currentTime;
		
		var totalFrames: int = _frameTimes.length;
		_timelineControls.sliderValue = (_frameIndex/totalFrames);
	}
}

private function getValueForWayId(wayId: String): String
{
	if (typeof _ways[wayId] === 'undefined')
		return null;
		
	var way: Object = _ways[wayId];

	if (_valueData === null)
		return null;

	var currentValues: Array;
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = _valueData[currentTime];
	}
	else
	{
		currentValues = _valueData;
	}
	
	var resultFound: Boolean = false;
	var result: String;
	for each (var values: Array in currentValues)
	{
		var matchKeys: Object = {};
		var thisValue: String = null;		
		for (var i:int = 0; i<values.length; i+=1)
		{
			if (i===_valueColumnIndex)
			{
				thisValue = values[i];
			}
			else if (i!==_timeColumnIndex)
			{
				var headerName: String = _valueHeaders[i];
				matchKeys[headerName] = values[i];	
			}
		}
		
		var allMatch: Boolean = true;
		for (var key: String in matchKeys)
		{
			var value:String = matchKeys[key];
			
			if (way.tags[key]!==value)
				allMatch = false;	
		}
		
		if (allMatch)
		{
			resultFound = true;
			result = thisValue;
		}
	}

	if (resultFound)
		return result;
	else
		return null;
}

private function addInlay(leftX: Number, topY: Number, rightX: Number, bottomY: Number, topLat: Number, leftLon: Number, bottomLat: Number, rightLon: Number): void
{
	var width: Number = (rightX-leftX);
	var height: Number = (bottomY-topY);
	
	var widthLon: Number = (rightLon-leftLon);
	var heightLat: Number = (bottomLat-topLat);
	
	var scaleX: Number = (width/widthLon);
	var scaleY: Number = (height/heightLat);

	var latLonToXYMatrix: Matrix = new Matrix();
	latLonToXYMatrix.translate(-leftLon, -topLat);
	latLonToXYMatrix.scale(scaleX, scaleY);	

	var xYToLatLonMatrix: Matrix = latLonToXYMatrix.clone();
	xYToLatLonMatrix.invert();
	
	var worldTopLeftLatLon: Object = getLatLonFromXY(new Point(leftX, topY), _xYToLatLonMatrix);
	var worldBottomRightLatLon: Object = getLatLonFromXY(new Point(rightX, bottomY), _xYToLatLonMatrix);
	
	_inlays.push({
		latLonToXYMatrix: latLonToXYMatrix,
		xYToLatLonMatrix: xYToLatLonMatrix,
		worldTopLeftLatLon: worldTopLeftLatLon,
		worldBottomRightLatLon: worldBottomRightLatLon
	});
}

private function cropPoint(input: Point, area: Rectangle): Point
{
	var result: Point = input.clone();
	
	if (result.x<area.left)
		result.x = area.left;
	
	if (result.x>area.right)
		result.x = area.right;	
	
	if (result.y<area.top)
		result.y = area.top;
	
	if (result.y>area.bottom)
		result.y = area.bottom;	

	return result;	
}

private function drawMapIntoMainBitmap(): void
{		
	doRedraw(_mainShape.graphics, _settings.width, _settings.height, _latLonToXYMatrix, _xYToLatLonMatrix);
			
	for each (var inlay: Object in _inlays)
	{
		var screenTopLeft: Point = getXYFromLatLon(inlay.worldTopLeftLatLon, _latLonToXYMatrix);
		var screenBottomRight: Point = getXYFromLatLon(inlay.worldBottomRightLatLon, _latLonToXYMatrix);
		
		var screenArea: Rectangle = new Rectangle(0, 0, _settings.width, _settings.height);
		
		var croppedScreenTopLeft: Point = cropPoint(screenTopLeft, screenArea);
		var croppedScreenBottomRight: Point = cropPoint(screenBottomRight, screenArea);
		
		var inlayWidth: Number = (croppedScreenBottomRight.x-croppedScreenTopLeft.x);
		var inlayHeight: Number = (croppedScreenBottomRight.y-croppedScreenTopLeft.y);
		
		if ((inlayWidth<1)||(inlayHeight<1))
			continue;
		
		var inlayScreenLeftX: Number = croppedScreenTopLeft.x;
		var inlayScreenTopY: Number = croppedScreenTopLeft.y;
		
		var localTopLeft: Point = croppedScreenTopLeft.subtract(screenTopLeft);

		var croppedLatLonToXYMatrix: Matrix = inlay.latLonToXYMatrix.clone();
		croppedLatLonToXYMatrix.translate(-localTopLeft.x, -localTopLeft.y);
		
		var croppedXYToLatLonMatrix: Matrix = croppedLatLonToXYMatrix.clone();
		croppedXYToLatLonMatrix.invert();
		
		var drawingSurface: Shape = new Shape();

		var bitmapData:BitmapData = new BitmapData(inlayWidth, inlayHeight, false, _oceanColor);
		
		doRedraw(drawingSurface.graphics, inlayWidth, inlayHeight, croppedLatLonToXYMatrix, croppedXYToLatLonMatrix);
		bitmapData.draw(drawingSurface, new Matrix());

		var inlayMatrix: Matrix = new Matrix();
		inlayMatrix.translate(inlayScreenLeftX, inlayScreenTopY);

		_mainShape.graphics.beginBitmapFill(bitmapData, inlayMatrix, false);
		_mainShape.graphics.drawRect(inlayScreenLeftX, inlayScreenTopY, inlayWidth, inlayHeight);
		_mainShape.graphics.endFill();
	}

	_mainBitmap.bitmapData.draw(_mainShape, new Matrix());
	
	_mainBitmapTopLeftLatLon = getLatLonFromXY(new Point(0, 0), _xYToLatLonMatrix);
	_mainBitmapBottomRightLatLon = getLatLonFromXY(new Point(_settings.width, _settings.height), _xYToLatLonMatrix);
}

private function drawMainBitmapIntoViewer(): void
{
	viewer.graphics.clear();
	
	if ((_mainBitmapTopLeftLatLon===null)||
		(_mainBitmapBottomRightLatLon===null))
		return;
		
	var screenBitmapTopLeft: Point = getXYFromLatLon(_mainBitmapTopLeftLatLon, _latLonToXYMatrix);
	var screenBitmapBottomRight: Point = getXYFromLatLon(_mainBitmapBottomRightLatLon, _latLonToXYMatrix);	

	var screenBitmapLeft: Number = screenBitmapTopLeft.x;
	var screenBitmapTop: Number = screenBitmapTopLeft.y;
	
	var screenBitmapWidth: Number = (screenBitmapBottomRight.x-screenBitmapTopLeft.x);
	var screenBitmapHeight: Number = (screenBitmapBottomRight.y-screenBitmapTopLeft.y);
	
	var bitmapTransform: Matrix = new Matrix();
	bitmapTransform.scale((screenBitmapWidth/_settings.width), (screenBitmapHeight/_settings.height));
	bitmapTransform.translate(screenBitmapLeft, screenBitmapTop);
	
	viewer.graphics.beginBitmapFill(_mainBitmap.bitmapData, bitmapTransform, false);
	viewer.graphics.drawRect(screenBitmapLeft, screenBitmapTop, screenBitmapWidth, screenBitmapHeight);
	viewer.graphics.endFill();	
}

private function translateMapByScreenPixels(x: Number, y: Number, dragging: Boolean = false): void
{
	_latLonToXYMatrix.translate(x, y);
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
}

private function zoomMapByFactorAroundPoint(zoomFactor: Number, center: Point, dragging: Boolean = false): void
{
	var translateToOrigin: Matrix = new Matrix();
	translateToOrigin.translate(-center.x, -center.y);
	
	var scale: Matrix = new Matrix();
	scale.scale(zoomFactor, zoomFactor);
	
	var translateFromOrigin: Matrix = new Matrix();
	translateFromOrigin.translate(center.x, center.y);

	var zoom: Matrix = new Matrix();
	zoom.concat(translateToOrigin);
	zoom.concat(scale);
	zoom.concat(translateFromOrigin);
	
	_latLonToXYMatrix.concat(zoom);
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();

	for each (var inlay: Object in _inlays)
	{
		var newLatLonToXYMatrix: Matrix = inlay.latLonToXYMatrix.clone();
		newLatLonToXYMatrix.concat(scale);
		
		var newXYToLatLonMatrix: Matrix = newLatLonToXYMatrix.clone();
		newXYToLatLonMatrix.invert();
		
		inlay.latLonToXYMatrix = newLatLonToXYMatrix;
		inlay.xYToLatLonMatrix = newXYToLatLonMatrix;
	}
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
		
	updateZoomSliderDisplay();
}

private function createViewerElements(): void
{
	_mainShape = new Shape();
	var bitmapData:BitmapData = new BitmapData(width, height, false, _oceanColor);
	_mainBitmap = new Bitmap(bitmapData);
	_mainBitmap.x = 0;
	_mainBitmap.y = 0;
	
	_zoomSlider = new VSlider();
	_zoomSlider.x = 4;
	_zoomSlider.y = 50;
	_zoomSlider.height = 150;
	_zoomSlider.showDataTip = false;
	_zoomSlider.minimum = 0;
	_zoomSlider.maximum = 1;
	_zoomSlider.liveDragging = true;

	_zoomSlider.addEventListener( SliderEvent.CHANGE, onZoomThumbDrag );
	_zoomSlider.addEventListener( SliderEvent.THUMB_DRAG, onZoomThumbDrag );
	_zoomSlider.addEventListener( SliderEvent.THUMB_RELEASE, onZoomThumbRelease );
	_zoomSlider.addEventListener( SliderEvent.THUMB_PRESS, onZoomThumbRelease );
	
	addChild(_zoomSlider);

	var plusImage: BitmapAsset = BitmapAsset( new PlusImage() );
	var minusImage: BitmapAsset = BitmapAsset( new MinusImage() );

	var blackTint:ColorTransform = new ColorTransform();
	blackTint.color = 0x000000;
	
	plusImage.x = 6;
	plusImage.y = 40;
	plusImage.transform.colorTransform = blackTint;
	viewer.addChild(plusImage);
	
	minusImage.x = 6;
	minusImage.y = 195;
	minusImage.transform.colorTransform = blackTint;
	viewer.addChild(minusImage);
	
	_credit = new Label();
	_credit.htmlText = _settings.credit_text;
	_credit.width = 150;
	_credit.height = 15;
	_credit.setStyle('text-align', 'right');
	_credit.setStyle('color', _settings.credit_color);
	
    _credit.addEventListener( MouseEvent.CLICK, function(): void {
    	var url:String = "http://"+_credit.text;
        var request:URLRequest = new URLRequest(url);
		navigateToURL(request); 	  	
 	});
	
	viewer.addChild(_credit);

	_title = new TextField();
	_title.htmlText = '<p align="center"><u>'+_settings.title_text+'</u></p>';
	_title.width = _settings.width;
	_title.height = (_settings.title_size*1.5);
	_title.textColor = _settings.title_color;
	_title.background = true;
	_title.backgroundColor = _settings.title_background_color;
//	_title.fontSize = _settings.title_size;
	_title.y = -1000;

	var titleFormat: TextFormat = _title.defaultTextFormat;
	titleFormat.size = _settings.title_size;
	titleFormat.font = 'Verdana';
	_title.defaultTextFormat = titleFormat;
	
	viewer.addChild(_title);

	repositionMoveableElements();
}

private function onZoomThumbDrag( event: SliderEvent ): void
{
	var pixelsPerDegreeLatitude: Number = calculatePixelsPerDegreeLatitudeFromZoomSlider();
	
	setPixelsPerDegreeLatitude(pixelsPerDegreeLatitude, true);
}

private function onZoomThumbRelease( event: SliderEvent ): void
{
	var pixelsPerDegreeLatitude: Number = calculatePixelsPerDegreeLatitudeFromZoomSlider();
	
	setPixelsPerDegreeLatitude(pixelsPerDegreeLatitude, false);	
}

private function getPixelsPerDegreeLatitude(): Number
{
	var pixelsPerDegreeLatitude: Number = _latLonToXYMatrix.d;
	
	return pixelsPerDegreeLatitude;
}

private function setPixelsPerDegreeLatitude(newPixelsPerDegreeLatitude: Number, dragging: Boolean = false): void
{
	var oldPixelsPerDegreeLatitude: Number = getPixelsPerDegreeLatitude();
	
	var zoomFactor: Number = (newPixelsPerDegreeLatitude/oldPixelsPerDegreeLatitude);
	
	var center: Point = new Point((_settings.width/2), (_settings.height/2));
	
	zoomMapByFactorAroundPoint(zoomFactor, center, dragging);
}

private function calculatePixelsPerDegreeLatitudeFromZoomSlider(): Number
{
	var sliderValue: Number = _zoomSlider.value;
	
	var lerpValue: Number = Math.pow(sliderValue, _settings.zoom_slider_power);

	var minPixelsPerDegreeLatitude: Number = (_settings.height/_settings.zoomed_out_degrees_per_pixel);
	var maxPixelsPerDegreeLatitude: Number = (_settings.height/_settings.zoomed_in_degrees_per_pixel);

	var oneMinusLerp: Number = (1-lerpValue);
	
	var result: Number = (minPixelsPerDegreeLatitude*oneMinusLerp)+
		(maxPixelsPerDegreeLatitude*lerpValue);
	
	return result;
}

private function updateZoomSliderDisplay(): void
{
	var pixelsPerDegreeLatitude: Number = getPixelsPerDegreeLatitude();

	var minPixelsPerDegreeLatitude: Number = (_settings.height/_settings.zoomed_out_degrees_per_pixel);
	var maxPixelsPerDegreeLatitude: Number = (_settings.height/_settings.zoomed_in_degrees_per_pixel);

	var lerpValue: Number = ((pixelsPerDegreeLatitude-minPixelsPerDegreeLatitude)/
		(maxPixelsPerDegreeLatitude-minPixelsPerDegreeLatitude));
	
	var sliderValue: Number = Math.pow(lerpValue, (1/_settings.zoom_slider_power));

	_zoomSlider.value = sliderValue;
}

private function setGradientValueRange(min: Number, max: Number): void
{
	_settings.is_gradient_value_range_set = true;
	_settings.gradient_value_min = min;
	_settings.gradient_value_max = max;
}

private function calculateFrameTimes(): void
{
	_frameTimes = [];
	
	for (var thisTime: String in _foundTimes)
	{
		if ((_settings.time_range_start!==null)&&(thisTime<_settings.time_range_start))
			continue;

		if ((_settings.time_range_end!==null)&&(thisTime>_settings.time_range_end))
			continue;
		
		_frameTimes.push(thisTime);
	}
	_frameTimes.sort();
	
	if (_frameIndex>(_frameTimes.length-1))
		_frameIndex = (_frameTimes.length-1);
}

private function onDataChange(): void
{
	if (_onDataChangeFunction!==null)
		ExternalInterface.call(_onDataChangeFunction, null);	
}

private function logError(message: String): void
{
	trace('Error: '+message);
	if (_onErrorFunction!==null)
		ExternalInterface.call(_onErrorFunction, message);	
}

private function getWayForWayId(wayId: String): Object
{
	var result: Object = _ways[wayId];
	
	trace('Found '+result);
	
	return result;	
}

private function isPointInsideClosedWay(pos: Point, way: Object): Boolean
{
	var xIntersections: Array = [];

	var lineStart: Point = null;
	var isFirst: Boolean = true;
	
	for each (var currentNd: String in way.nds)
	{
		var currentNode: Object = _nodes[currentNd];
		var lineEnd: Point = new Point(currentNode.lon, currentNode.lat);
		
		if (isFirst)
		{
			isFirst = false;
		}
		else
		{
			if (((lineStart.y>pos.y)&&(lineEnd.y<pos.y))||
				((lineStart.y<pos.y)&&(lineEnd.y>pos.y)))
			{
				var lineDirection: Point = new Point(lineEnd.x-lineStart.x, lineEnd.y-lineStart.y);
				var yDelta: Number = (pos.y-lineStart.y);
				var yProportion: Number = (yDelta/lineDirection.y);
				
				var xIntersect: Number = (lineStart.x+(lineDirection.x*yProportion));
				xIntersections.push(xIntersect);
			}
			
		}
		
		lineStart = lineEnd;
	}
	
	xIntersections.sort(function(a:Number, b:Number): int {
		if (a<b) return -1;
		else if (a>b) return 1;
		else return 0; 
	});
	
	var isInside: Boolean = false;
	for (var index: int = 0; index<(xIntersections.length-1); index += 2)
	{
		var leftX: Number = xIntersections[index];
		var rightX: Number = xIntersections[(index+1)];

		if ((leftX<=pos.x)&&(rightX>pos.x))
			isInside = true;
		
	}
				
	return isInside;
}

private function isPointOnWayLine(pos: Point, way: Object, thickness: Number): Boolean
{
	var lineStart: Point = null;
	var isFirst: Boolean = true;
	
	var thicknessSquared: Number = (thickness*thickness);
	
	var isInside: Boolean = false;
	for each (var currentNd: String in way.nds)
	{
		var currentNode: Object = _nodes[currentNd];
		var lineEnd: Point = new Point(currentNode.lon, currentNode.lat);
		
		if (isFirst)
		{
			isFirst = false;
		}
		else
		{
			var lineDirection: Point = new Point(lineEnd.x-lineStart.x, lineEnd.y-lineStart.y);
			
			var lineDirectionSquared: Number = ((lineDirection.x*lineDirection.x)+(lineDirection.y*lineDirection.y));
			
			var s: Number = ((pos.x-lineStart.x)*lineDirection.x)+((pos.y-lineStart.y)*lineDirection.y);
			s /= lineDirectionSquared;
			
			s = Math.max(s, 0);
			s = Math.min(s, 1);
			
			var closestPoint: Point = new Point((lineStart.x+s*lineDirection.x), (lineStart.y+s*lineDirection.y));
			
			var delta: Point = pos.subtract(closestPoint);
			
			var distanceSquared: Number = ((delta.x*delta.x)+(delta.y*delta.y));
			
			if (distanceSquared<thicknessSquared)
			{
				isInside = true;
				break;
			}
		}
		
		lineStart = lineEnd;
	}
	
				
	return isInside;
}

private function createBitmapBackground(width: Number, height: Number, viewingArea: Rectangle, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): BitmapData
{
	if (!_hasPointValues)
		return null;

	var blobRadius: Number = _settings.point_blob_radius;
	var twoBlobRadius: Number = (2*blobRadius);
	var blobRadiusSquared: Number = (blobRadius*blobRadius);
	var pointBlobValue: Number = _settings.point_blob_value;

	if (_settings.is_gradient_value_range_set)
	{
		var minValue: Number = _settings.gradient_value_min;
		var maxValue: Number = _settings.gradient_value_max;	
	}
	else
	{
		minValue = _smallestValue;
		maxValue = _largestValue;
	}
	var valueScale: Number = (1/(maxValue-minValue));

	_pointsGrid = new BucketGrid(viewingArea, 64, 64);

	var currentValues: Array;
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = _valueData[currentTime];
	}
	else
	{
		currentValues = _valueData;
	}
	
	var index: int = 0;
	for each (var values: Array in currentValues)
	{
		var lat: Number = values[_latitudeColumnIndex];
		var lon: Number = values[_longitudeColumnIndex];
		var pointValue: Number;
		if (_valueColumnIndex!==-1)
			pointValue = values[_valueColumnIndex];
		else
			pointValue = pointBlobValue;
			
		var boundingBox: Rectangle = new Rectangle(lon-blobRadius, lat-blobRadius, twoBlobRadius, twoBlobRadius);

		if (!viewingArea.intersects(boundingBox))
			continue;

		var latLon: Object = { 
			pos: new Point(lon, lat),
			index: index,
			value: pointValue
		};

		_pointsGrid.insertObjectAt(boundingBox, latLon);

		index += 1;
	}	
	
	var bitmapWidth: Number = (width/_bitmapBackgroundResolution);
	var bitmapHeight: Number = (height/_bitmapBackgroundResolution);
	
	var leftLon: Number = viewingArea.left;
	var rightLon: Number = viewingArea.right;
	var widthLon: Number = (rightLon-leftLon);
	var stepLon: Number = (widthLon/bitmapWidth);
	
	var topLat: Number = viewingArea.bottom;
	var bottomLat: Number = viewingArea.top;
	var heightLat: Number = (bottomLat-topLat);
	var stepLat: Number = (heightLat/bitmapHeight);
	
	var result: BitmapData = new BitmapData(bitmapWidth, bitmapHeight, false, 0xffff00);
	
	var pixelData: ByteArray = new ByteArray();
	
	var zeroColor: uint = getColorForValue(0, minValue, maxValue, valueScale);
	var fullColor: uint = getColorForValue(maxValue, minValue, maxValue, valueScale);
	
	var worldPoint: Point = new Point();
	for (var bitmapY: int = 0; bitmapY<bitmapHeight; bitmapY+=1)
	{
		worldPoint.y = (topLat+(stepLat*bitmapY));
		for (var bitmapX: int = 0; bitmapX<bitmapWidth; bitmapX+=1)
		{			
			worldPoint.x = (leftLon+(stepLon*bitmapX));
			
			var candidatePoints: Array = _pointsGrid.getContentsAtPoint(worldPoint);
			
			if (candidatePoints.length<1)
			{
				pixelData.writeUnsignedInt(zeroColor);
				continue;
			}
			
			var value: Number = 0;
			
			for each (var point: Object in candidatePoints)
			{
				var pos: Point = point.pos;
				var delta: Point = worldPoint.subtract(pos);
				var distanceSquared: Number = ((delta.x*delta.x)+(delta.y*delta.y));
				if (distanceSquared>blobRadiusSquared)
					continue;
				
				var distance: Number = Math.sqrt(distanceSquared);
				var lerp: Number = (1-(distance/blobRadius));
				
				value += (point.value*lerp);
			}

			if (value>=maxValue)
			{
				pixelData.writeUnsignedInt(fullColor);
				continue;
			}
			
			var color: uint = getColorForValue(value, minValue, maxValue, valueScale);
		
			pixelData.writeUnsignedInt(color);
		}	
	}
	
	pixelData.position = 0;
	
	result.setPixels(new Rectangle(0, 0, bitmapWidth, bitmapHeight), pixelData);
	
	return result;
}

private function loadAreaValues(linesArray: Array, headerLine: String, columnSeperator: String): void
{
	if (_valueColumnIndex===-1)
	{
		logError( 'Error loading CSV file "'+_valuesFileName+'" - missing value column from header "'+headerLine+'"');
		return;
	}
	
	_foundTimes = {};
	
	_valueData = [];
	
	for(var i : int = 1; i < linesArray.length; i++ )
	{
		var lineString: String = linesArray[i];
		var lineValues: Array = decodeCSVRow(lineString, columnSeperator);
		
		var thisValue: Number = (Number)(lineValues[_valueColumnIndex]);
		
		if ((i===1)||(thisValue<_smallestValue))
			_smallestValue = thisValue;
			
		if ((i===1)||(thisValue>_largestValue))
			_largestValue = thisValue;
		
		if (_hasTime)
		{
			var thisTime: String = lineValues[_timeColumnIndex];
			if (thisTime !== null)
			{
				if (typeof _foundTimes[thisTime] === 'undefined')
				{
					_foundTimes[thisTime] = true;
					_valueData[thisTime] = [];
				}
				
				_valueData[thisTime].push(lineValues);
			}
		}
		else
		{
			_valueData.push(lineValues);		
		}
		
	}
	
}

private function loadPointValues(linesArray: Array, headerLine: String, columnSeperator: String): void
{	
	_foundTimes = {};
		
	_valueData = [];
	
	for(var i : int = 1; i < linesArray.length; i++ )
	{
		var lineString: String = linesArray[i];
		var lineValues: Array = decodeCSVRow(lineString, columnSeperator);
		
		var thisLatitude: Number = (Number)(lineValues[_latitudeColumnIndex]);
		var thisLongitude: Number = (Number)(lineValues[_longitudeColumnIndex]);

		lineValues[_latitudeColumnIndex] = thisLatitude;
		lineValues[_longitudeColumnIndex] = thisLongitude;

		if (_valueColumnIndex!==-1)
		{
			var thisValue: Number = (Number)(lineValues[_valueColumnIndex]);
			lineValues[_valueColumnIndex] = thisValue;
			
			if ((i===1)||(thisValue<_smallestValue))
				_smallestValue = thisValue;
			
			if ((i===1)||(thisValue>_largestValue))
				_largestValue = thisValue;
		}
		
		if (_hasTime)
		{
			var thisTime: String = lineValues[_timeColumnIndex];
			if ((thisTime !== null)&&(thisTime!==''))
			{
				if (typeof _foundTimes[thisTime] === 'undefined')
				{
					_foundTimes[thisTime] = true;
					_valueData[thisTime] = [];
				}
				
				_valueData[thisTime].push(lineValues);
			}
		}
		else
		{
			_valueData.push(lineValues);		
		}
		
		_valueData.push(lineValues);		
	}	
}

private function getColorForValue(thisValue: Number, minValue: Number, maxValue: Number, valueScale: Number): int
{	
	var normalizedValue: Number = ((thisValue-minValue)*valueScale); 
	normalizedValue = Math.min(normalizedValue, 1.0);
	normalizedValue = Math.max(normalizedValue, 0.0);
	
	var fractionalIndex: Number = (normalizedValue*(_colorGradient.length-1));
	
	var lowerIndex: int = Math.floor(fractionalIndex);
	var higherIndex: int = Math.ceil(fractionalIndex);
	var lerpValue: Number = (fractionalIndex-lowerIndex);
	var oneMinusLerp: Number = (1.0-lerpValue);
	
	var lowerValue: Object = _colorGradient[lowerIndex];
	var higherValue: Object = _colorGradient[higherIndex];
	
	var red: int = (int)((lowerValue.red*oneMinusLerp)+(higherValue.red*lerpValue));
	var green: int = (int)((lowerValue.green*oneMinusLerp)+(higherValue.green*lerpValue));
	var blue: int = (int)((lowerValue.blue*oneMinusLerp)+(higherValue.blue*lerpValue));
	
	var setColor: int = ((red<<16)|(green<<8)|(blue<<0));
	
	return setColor;
}

private function getValuePointsNearLatLon(lat: Number, lon: Number, radius: Number = 0): Object
{
	if (radius===0)
		radius = _settings.point_blob_radius;
	
	var radiusSquared: Number = (radius*radius);

	var currentValues: Array;
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = _valueData[currentTime];
	}
	else
	{
		currentValues = _valueData;
	}
		
	var result: Array = [];
	for each (var values: Array in currentValues)
	{
		var valueLat: Number = values[_latitudeColumnIndex];
		var valueLon: Number = values[_longitudeColumnIndex];
		
		var deltaLat: Number = (valueLat-lat);
		var deltaLon: Number = (valueLon-lon);
		
		var distanceSquared: Number = ((deltaLat*deltaLat)+(deltaLon*deltaLon));
		
		if (distanceSquared<radiusSquared)
		{
			var output: Object = {};
			for(var headerIndex:int = 0; headerIndex < _valueHeaders.length; headerIndex++ )
			{
				var header: String = _valueHeaders[headerIndex].toLowerCase();

				output[header] = values[headerIndex];
			}
			
			result.push(output);
		}
	
	}
	
	return result;
}

private function setSetting(key: String, value: String): void
{
	if (!_settings.hasOwnProperty(key))
	{
		logError('Unknown key in setSetting('+key+')');
		return;
	}
	
	if (typeof _settings[key] === "Number")
		_settings[key] = value as Number;
	else
		_settings[key] = value;
		
	var changeHandlers: Object =
	{
		'title_text': function(): void {
			_title.htmlText = '<p align="center"><u>'+_settings.title_text+'</u></p>';
			if (_settings.title_text!=='')
				_title.y = 0;
			else
				_title.y = -1000;
		},
		'time_range_start': function(): void {
			calculateFrameTimes();
			updateTimelineDisplay();
		},
		'time_range_end': function(): void {
			calculateFrameTimes();
			updateTimelineDisplay();
		}
	}
	
	if (changeHandlers.hasOwnProperty(key))
		changeHandlers[key]();
}

private function repositionMoveableElements(): void
{
	if (_credit !== null)
	{
		_credit.x = (_settings.width-120);
		_credit.y = (_settings.height-17);
	}
		
	if (_title !== null)
	{
		_title.width = _settings.width;
		_title.x = 0;
	}

	if (_timelineControls !== null)
	{
		var verticalCenter: Number = ((_settings.height/2)-40);
		_timelineControls.y = (_settings.height-50);
	}

}

private function getLatLonViewingArea(): Object
{
	var topLeftScreen: Point = new Point(0, 0);
	var bottomRightScreen: Point = new Point(_settings.width, _settings.height);
		
	var topLeftLatLon: Object = getLatLonFromXY(topLeftScreen, _xYToLatLonMatrix);
	var bottomRightLatLon: Object = getLatLonFromXY(bottomRightScreen, _xYToLatLonMatrix);

	var result: Object = {
		topLat: topLeftLatLon.lat,
		leftLon: topLeftLatLon.lon,
		bottomLat: bottomRightLatLon.lat,
		rightLon: bottomRightLatLon.lon
	};
	
	return result;
}

private function removeAllInlays(): void
{
	_inlays	= [];
	
	_dirty = true;
}

private function removeAllWays(): void
{
	_ways = {};
	_nodes = {};

  	_tagMap = {};
	_lastSetWayIds = {};
	
	_dirty = true;
}

]]>
</mx:Script>
<mx:UIComponent id="viewer"></mx:UIComponent>
	
</mx:Application>
