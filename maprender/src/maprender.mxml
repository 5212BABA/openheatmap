<?xml version="1.0" encoding="utf-8"?>

<!--
OpenHeatMap renderer - a flash component to display and explore map visualizations
Copyright (C) 2010 Pete Warden <pete@petewarden.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" 
    width="800" height="600" 
    applicationComplete="startup()">

<mx:Script>
<![CDATA[

import BucketGrid;
import ExternalImageView;
import TimelineControls;

import flash.external.ExternalInterface;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import flash.text.TextField;

import mx.controls.Image;
import mx.controls.Label;
import mx.controls.Text;
import mx.controls.TextArea;
import mx.controls.VSlider;
import mx.controls.sliderClasses.Slider;
import mx.core.BitmapAsset;
import mx.events.FlexEvent;
import mx.events.SliderEvent;

public var _mainShape:Shape = null;
public var _mainBitmap: Bitmap = null;
public var _dirty: Boolean = true;
public var _redrawCountdown: int = 0;

public var _wayDefaults: Object = {
	color: 0x000000,
	alpha: 1.0,
	line_thickness: 0,
	line_color: 0x000000,
	line_alpha: 0.0
};

public var _colorGradient: Array = [
	{alpha: 0x00, red: 0x00, green: 0xb0, blue: 0x00},
	{alpha: 0x7f, red: 0xe0, green: 0xe0, blue: 0x00},
	{alpha: 0xff, red: 0xff, green: 0x00, blue: 0x00},
];

public var _onClickFunction: String = null;
public var _onDoubleClickFunction: String = null;
public var _onMouseDownFunction: String = null;
public var _onMouseUpFunction: String = null;
public var _onMouseOverFunction: String = null;
public var _onMouseOutFunction: String = null;
public var _onMouseMoveFunction: String = null;
public var _onFrameRenderFunction: String = null;
public var _onDataChangeFunction: String = null;
public var _onWaysLoadFunction: String = null;
public var _onValuesLoadFunction: String = null;
public var _onErrorFunction: String = null;
public var _onViewChangeFunction: String = null;

public var _nodes: Object = {};
public var _ways: Object = {};

public var _waysLoader: URLLoader;
public var _waysFileName: String = "";

public var _valuesLoader: URLLoader;
public var _valuesFileName: String = "";

public var _valueHeaders: Array = null;
public var _valueData: Array = null;
public var _timeColumnIndex: int;
public var _valueColumnIndex: int;

public var _smallestValue: Number;
public var _largestValue: Number;

public var _hasTime: Boolean = false;
public var _frameTimes: Array = [];
public var _frameIndex: Number = 0;

public var _tagMap: Object = {};

public var _latLonToXYMatrix: Matrix = new Matrix();
public var _xYToLatLonMatrix: Matrix = new Matrix();

public var _worldBoundingBox: Rectangle = new Rectangle();
public var _waysGrid: BucketGrid = null;

public var _timelineControls: TimelineControls = null;

public var _inlays: Array = [];

public var _valuesDirty: Boolean = false;

public var _mainBitmapTopLeftLatLon: Object = null;
public var _mainBitmapBottomRightLatLon: Object = null;

public var _isDragging: Boolean = false;
public var _lastDragPosition: Point = null;
public var _lastClickTime: Number = 0;

public var _zoomSlider: Slider = null;
[Embed(source="embed_images/plus.gif")]
public var PlusImage:Class;
[Embed(source="embed_images/minus.gif")]
public var MinusImage:Class;

public var _foundTimes: Object = {};

public var _hasBitmapBackground: Boolean = false;

public var _hasPointValues: Boolean = false;
public var _latitudeColumnIndex: int = -1;
public var _longitudeColumnIndex: int = -1;

public var _pointsGrid: BucketGrid = null;

public var _mapTiles: Object = {};

public var _settings: Object =
{
	width: 800,
	height: 600,
	zoom_slider_power: 5.0,
	zoomed_out_degrees_per_pixel: -180,
	zoomed_in_degrees_per_pixel: -0.01,
	is_gradient_value_range_set: false,
	gradient_value_min: 0,
	gradient_value_max: 0,
	point_blob_radius: 1.0,
	point_blob_value: 1.0,
	credit_text: '<a href="http://openheatmap.com"><u>OpenHeatMap</u></a> ',
	credit_color: '0x303030',
	title_text: '',
	title_size: 15,
	title_color: '0x000000',
	title_background_color: '0xd0e0ff',
	title_background_alpha: 1.0,
	time_range_start: null,
	time_range_end: null,
    force_outlines: false,
    show_map_tiles: false,
    map_server_root: 'http://a.tile.openstreetmap.org/',
    map_tile_width: 256,
    map_tile_height: 256,
	map_tile_origin_lat: 85.05112877980659,
	map_tile_origin_lon: -180,
	map_tile_match_factor: 1.2,
	world_lat_height: -170.102258,
	world_lon_width: 360,
	inlay_border_color: 0x000000,
	ocean_color: 0xd0e0ff,
	information_alpha: 1.0,
	is_point_blob_radius_in_pixels: false,
	point_bitmap_scale: 2,
	tab_height: 15,
	clear_ways: true,
	is_value_distance: false,
	point_blob_tile_size: 128,
	show_tabs: true,
	show_zoom: true,
	allow_pan: true,
	point_drawing_shape: 'blob',
	circle_line_color: 0x000000,
	circle_line_alpha: 1.0,
	circle_line_thickness: 1.0,
	max_fps: 2.0,
	circle_minimum_radius: 2.0,
	default_pin_image: '/static/images/map_pin.png'
};

public var _lastSetWayIds: Object = {};

public var _credit: Label = null;
public var _title: TextField = null;

public var _popups: Array = [];

public var _informationLayerShape:Shape = null;
public var _informationLayerBitmap: Bitmap = null;

public var _mapTilesDirty: Boolean = true;
	
public var _tabColumnIndex: int = -1;
public var _hasTabs: Boolean = false;
public var _tabNames: Array = [];
public var _tabInfo: Object = {};
public var _selectedTabIndex: int = 0;
public var _hoveredTabIndex: int = -1;
	
public var _pointBlobBitmap: BitmapData = null;
public var _pointBlobBitmapWidth: int = 0;
public var _pointBlobBitmapHeight: int = 0;
public var _pointBlobTileX: int = 0;
public var _pointBlobTileY: int = 0;
public var _pointBlobStillRendering: Boolean = false;

public var _wayLayers: Array = [];
public var _plusImage: BitmapAsset = null;
public var _minusImage: BitmapAsset = null;
	
[Embed(source="embed_images/thumb.png")]
public var VThumbImage:Class;

[Embed(source="embed_images/track.png")]
public var VTrackImage:Class;

public var _tooltipColumnIndex: int;
	
public var _lastAnimationFrameTime: Number = 0;
	
public var _externalImages: Object = {};
	
private function getURLInput(name: String, defaultValue: String = null): String
{
	if (mx.core.Application.application.parameters.hasOwnProperty(name))
		return mx.core.Application.application.parameters[name];
	else
		return defaultValue;
}
	
public function startup():void
{
	flash.system.Security.allowDomain("*");
	flash.system.Security.allowInsecureDomain("*");

	var width: Number = Number(getURLInput('width', '800'));
	var height: Number = Number(getURLInput('height', '600'));

	setSize(width, height);

	createViewerElements();

	setLatLonViewingArea(80, -180, -75, 180);
		    
    viewer.addEventListener( MouseEvent.CLICK, mapMouseClickHandler );
	// Pete- I'm synthesizing double-click events, see the single click handler for details
//    viewer.addEventListener( MouseEvent.DOUBLE_CLICK, mapMouseDoubleClickHandler );
    viewer.addEventListener( MouseEvent.MOUSE_DOWN, mapMouseDownHandler );
    viewer.addEventListener( MouseEvent.MOUSE_MOVE, mapMouseMoveHandler );
    viewer.addEventListener( MouseEvent.MOUSE_OUT, mapMouseOutHandler );
    viewer.addEventListener( MouseEvent.MOUSE_OVER, mapMouseOverHandler );
    viewer.addEventListener( MouseEvent.MOUSE_UP, mapMouseUpHandler );
//    viewer.addEventListener( MouseEvent.MOUSE_WHEEL, mapMouseWheelHandler );
//	viewer.doubleClickEnabled = true;

	_dirty = true;

	addEventListener(Event.ENTER_FRAME, doEveryFrame);
	
	ExternalInterface.addCallback("setSize", setSize);      	
	ExternalInterface.addCallback("setLatLonViewingArea", setLatLonViewingArea);      	
	ExternalInterface.addCallback("setWayDefault", setWayDefault);
	ExternalInterface.addCallback('bind', bind);
	ExternalInterface.addCallback("loadWaysFromFile", loadWaysFromFile);      	
	ExternalInterface.addCallback("loadValuesFromFile", loadValuesFromFile);
	ExternalInterface.addCallback("setColorGradient", setColorGradient);	
	ExternalInterface.addCallback("getWaysContainingLatLon", getWaysContainingLatLon);
	ExternalInterface.addCallback("getValueForWayId", getValueForWayId);
	ExternalInterface.addCallback("addInlay", addInlay);
	ExternalInterface.addCallback("translateMapByScreenPixels", translateMapByScreenPixels);
	ExternalInterface.addCallback("getPixelsPerDegreeLatitude", getPixelsPerDegreeLatitude);
	ExternalInterface.addCallback("setPixelsPerDegreeLatitude", setPixelsPerDegreeLatitude);
	ExternalInterface.addCallback("setGradientValueRange", setGradientValueRange);
	ExternalInterface.addCallback("getWayForWayId", getWayForWayId);
	ExternalInterface.addCallback("getValuePointsNearLatLon", getValuePointsNearLatLon);
	ExternalInterface.addCallback("loadValuesFromCSVString", loadValuesFromCSVString);
	ExternalInterface.addCallback("setSetting", setSetting);
	ExternalInterface.addCallback("getLatLonViewingArea", getLatLonViewingArea);
	ExternalInterface.addCallback("removeAllInlays", removeAllInlays);
	ExternalInterface.addCallback("removeAllWays", removeAllWays);
	ExternalInterface.addCallback("getAllInlays", getAllInlays);
	ExternalInterface.addCallback("addPopup", addPopup);
	ExternalInterface.addCallback("removeAllPopups", removeAllPopups);
	ExternalInterface.addCallback("getValueHeaders", getValueHeaders);
	ExternalInterface.addCallback("addPopupAtScreenPosition", addPopupAtScreenPosition);
	ExternalInterface.addCallback("setAttributeForMatchingWays", setAttributeForMatchingWays);
	ExternalInterface.addCallback("setAnimationTime", setAnimationTime);
	ExternalInterface.addCallback("getAnimationTime", getAnimationTime);
	ExternalInterface.addCallback("getTabInfo", getTabInfo);
	ExternalInterface.addCallback("selectTab", selectTab);

	var onLoadFunction: String = getURLInput('onload', 'onMapCreated');
	var mapName: String = getURLInput('mapname', 'openheatmap');
	ExternalInterface.call(onLoadFunction, mapName);
}

private function setWayDefault(propertyName: String, propertyValue: Object): void
{
	_wayDefaults[propertyName] = propertyValue;
	_dirty = true;
}

private function getWayProperty(propertyName: String, wayInfo: Object = null): Object
{
	if ((wayInfo !== null) && (wayInfo.hasOwnProperty(propertyName)))
		return wayInfo[propertyName];
	else if (_wayDefaults.hasOwnProperty(propertyName))
		return _wayDefaults[propertyName];
	else
		return null;
}

private function doTagsMatch(tags: Array, lineInfo: Object): Boolean
{
	var result: Boolean = false;
	if (tags === null)
	{
		result = true;
	}
	else
	{
		if (lineInfo.hasOwnProperty('tags'))
		{
			var myTags: Array = lineInfo.tags;
			
			for each (var myTag: String in myTags)
			{
				for each (var tag: String in tags)
				{
					if (myTag === tag)
						result = true;
				}
			}
			
		}
	}
		
	return result;
}

private function getTagsFromArgument(tagsArgument: Object): Array
{
	if (tagsArgument === null)
		return null;
		
	if (tagsArgument is Array)
		return tagsArgument as Array;
	else
		return [ tagsArgument ];
}

private function bind(eventName: String, functionName: String): void
{
	eventName = eventName.toLowerCase();
	
	if (eventName == 'click')
		_onClickFunction = functionName;
	else if (eventName == 'doubleclick')
		_onDoubleClickFunction = functionName;
	else if (eventName == 'mousedown')
		_onMouseDownFunction = functionName;
	else if (eventName == 'mouseup')
		_onMouseUpFunction = functionName;
	else if (eventName == 'mouseover')
		_onMouseOverFunction = functionName;
	else if (eventName == 'mouseout')
		_onMouseOutFunction = functionName;
	else if (eventName == 'mousemove')
		_onMouseMoveFunction = functionName;
	else if (eventName == 'framerender')
		_onFrameRenderFunction = functionName;
	else if (eventName == 'datachange')
		_onDataChangeFunction = functionName;
	else if (eventName == 'waysload')
		_onWaysLoadFunction = functionName;
	else if (eventName == 'valuesload')
		_onValuesLoadFunction = functionName;
	else if (eventName == 'error')
		_onErrorFunction = functionName;
	else if (eventName == 'viewchange')
		_onViewChangeFunction = functionName;
	else
		logError( 'Unknown event name passed to OpenHeatMap::bind - "'+
			eventName+'" (expected click, doubleclick, mousedown, mouseup, mouseover, mouseout, framerender, datachange, waysload, valuesload, error or viewchange)');
}

private function setSize(width: Number, height: Number): void
{
	this.width = width;
	this.height = height;
	
	_settings.width = width;
	_settings.height = height;
	
//	if (_timelineControls !== null)
//		_timelineControls.setWidth(width);

	var bitmapData:BitmapData = new BitmapData(width, height, false, _settings.ocean_color);
	_mainBitmap = new Bitmap(bitmapData);
	_mainBitmap.x = 0;
	_mainBitmap.y = 0;

	var informationBitmapData:BitmapData = new BitmapData(width, height, true, _settings.ocean_color);
	_informationLayerBitmap = new Bitmap(informationBitmapData);
	_informationLayerBitmap.x = 0;
	_informationLayerBitmap.y = 0;

	repositionMoveableElements();
	
	_dirty = true;	
}

private function setLatLonViewingArea(topLat: Number, leftLon: Number, bottomLat: Number, rightLon: Number): void
{
	topLat = latitudeToMercatorLatitude(topLat);
	bottomLat = latitudeToMercatorLatitude(bottomLat);
	
	var widthLon: Number = (rightLon-leftLon);
	var heightLat: Number = (bottomLat-topLat);
	
	var scaleX: Number = (_settings.width/widthLon);
	var scaleY: Number = (_settings.height/heightLat);

	var newMatrix: Matrix = new Matrix();
	newMatrix.translate(-leftLon, -topLat);
	newMatrix.scale(scaleX, scaleY);

	setLatLonToXYMatrix(newMatrix);
}

private function setLatLonToXYMatrix(newMatrix: Matrix): void
{
	_latLonToXYMatrix = newMatrix;
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();
	
	updateZoomSliderDisplay();
}

private function getXYFromLatLon(latLon: Object, latLonToXYMatrix: Matrix): Point
{
	var latLonPoint: Point = new Point(latLon.lon, latitudeToMercatorLatitude(latLon.lat));
	
	var result: Point = latLonToXYMatrix.transformPoint(latLonPoint);

	return result;
}

private function getLatLonFromXY(xYPoint: Point, xYToLatLonMatrix: Matrix): Object
{
	var latLonPoint: Point = xYToLatLonMatrix.transformPoint(xYPoint);
	
	var result: Object = {
			lat: mercatorLatitudeToLatitude(latLonPoint.y),
			lon: latLonPoint.x
	}
	
	return result;
}

private function makeEventArgument(event:MouseEvent): Object
{
	var mouseX: Number = event.stageX;
	var mouseY: Number = event.stageY;

	var mainLatLon: Object = getLatLonFromXY(new Point(mouseX, mouseY), _xYToLatLonMatrix);
	
	var mouseLatLon: Object = null;
	for each (var inlay: Object in _inlays)
	{
		var screenTopLeft: Point = getXYFromLatLon(inlay.worldTopLeftLatLon, _latLonToXYMatrix);
		var screenBottomRight: Point = getXYFromLatLon(inlay.worldBottomRightLatLon, _latLonToXYMatrix);

		if ((mouseX>=screenTopLeft.x)&&
			(mouseX<screenBottomRight.x)&&
			(mouseY>=screenTopLeft.y)&&
			(mouseY<screenBottomRight.y))
		{
			var localX: Number = (mouseX-screenTopLeft.x);
			var localY: Number = (mouseY-screenTopLeft.y);
			mouseLatLon = getLatLonFromXY(new Point(localX, localY), inlay.xYToLatLonMatrix);
		}
	}
	
	if (mouseLatLon === null)
		mouseLatLon = mainLatLon;
	
	var mapPointData:Object = new Object();
	mapPointData.lon = mouseLatLon.lon;
	mapPointData.lat = mouseLatLon.lat;
	mapPointData.x = mouseX;
	mapPointData.y = mouseY;

	return mapPointData;
}
	
private function mapMouseClickHandler( event:MouseEvent ): Boolean
{
	if (isEventInTopBar(event))
		return onTopBarClick(event);
	
	var continueHandling: Boolean;
	if (_onClickFunction !== null)
		continueHandling = ExternalInterface.call(_onClickFunction, makeEventArgument(event));
	else
		continueHandling = true;

	// Pete - I can't get double-click events to fire reliably, so I've hard-coded an interval within which the
	// second normal click event triggers the double-click handler. Ugh, I feel dirty...
	var currentTime: Number = new Date().getTime();
	var sinceLastClick: Number = (currentTime-_lastClickTime);
	if (sinceLastClick<750)
	{
		mapMouseDoubleClickHandler(event);
		_lastClickTime = 0;
	}
	else
	{
		_lastClickTime = currentTime;	
	}
		
	return true;
}

private function mapMouseDoubleClickHandler( event:MouseEvent ): Boolean
{ 
	if (isEventInTopBar(event))
		return onTopBarDoubleClick(event);

	var continueHandling: Boolean;
	if (_onDoubleClickFunction !== null)
		continueHandling = ExternalInterface.call(_onDoubleClickFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	if (continueHandling&&_settings.allow_pan)
	{
		var center: Point = new Point(event.localX, event.localY);
		var zoomFactor: Number = 2.0;
		
		zoomMapByFactorAroundPoint(zoomFactor, center);
		
		onViewChange();	
	}
		
	return true;
}

private function mapMouseDownHandler( event:MouseEvent ): Boolean
{ 
	if (isEventInTopBar(event))
		return onTopBarMouseDown(event);

	var continueHandling: Boolean;
	if (_onMouseDownFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseDownFunction, makeEventArgument(event));
	else
		continueHandling = true;
	
	if (continueHandling&&_settings.allow_pan)
	{
		var mousePosition: Point = new Point(event.localX, event.localY);

		_isDragging = true;
		_lastDragPosition = mousePosition; 
	}
	
	return true;
}

private function mapMouseUpHandler( event:MouseEvent ): Boolean
{ 
	if (isEventInTopBar(event))
		return onTopBarMouseUp(event);

	var continueHandling: Boolean;
	if (_onMouseUpFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseUpFunction, makeEventArgument(event));
	else
		continueHandling = true;
	
	if (continueHandling&&_settings.allow_pan)
	{
		if (_isDragging)
		{
			var mousePosition: Point = new Point(event.localX, event.localY);
	
			var positionChange: Point = mousePosition.subtract(_lastDragPosition);
	
			translateMapByScreenPixels(positionChange.x, positionChange.y, false);
	
			_isDragging = false;
			
			onViewChange();
		}
	}
	
	return true;
}

private function mapMouseOverHandler( event:MouseEvent ): Boolean
{ 
	if (isEventInTopBar(event))
		return onTopBarMouseOver(event);

	var continueHandling: Boolean;
	if (_onMouseOverFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseOverFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	return true;
}

private function mapMouseOutHandler( event:MouseEvent ): Boolean
{ 
	if (isEventInTopBar(event))
		return onTopBarMouseOut(event);

	var continueHandling: Boolean;
	if (_onMouseOutFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseOutFunction, makeEventArgument(event));
	else
		continueHandling = true;
		
	return true;
}

private function mapMouseMoveHandler( event:MouseEvent): Boolean
{ 
	if (isEventInTopBar(event))
		return onTopBarMouseMove(event);

	var continueHandling: Boolean;
	if (_onMouseMoveFunction !== null)
		continueHandling = ExternalInterface.call(_onMouseMoveFunction, makeEventArgument(event));
	else
		continueHandling = true;

	if (continueHandling&&_settings.allow_pan)
	{
		if (_isDragging)
		{
			var mousePosition: Point = new Point(event.localX, event.localY);
	
			var positionChange: Point = mousePosition.subtract(_lastDragPosition);
	
			translateMapByScreenPixels(positionChange.x, positionChange.y, true);
	
			_lastDragPosition = mousePosition;
		}
	}
			
	return true;
}

private function doEveryFrame(event: Event): void
{		
	if ((_zoomSlider==null)&&_settings.show_zoom)
		createZoomSlider();
	
	if ((_zoomSlider!=null)&&!_settings.show_zoom)
		destroyZoomSlider();
	
	if (_redrawCountdown>0)
	{
		_redrawCountdown -= 1;
		if (_redrawCountdown===0)
			_dirty = true;
	}
	
	if (_valuesDirty&&(_redrawCountdown===0))
	{
		if (!_hasPointValues)
		{
			setWaysFromValues();
			_dirty = true;
		}
		_valuesDirty = false;		
	}
	
	if (_dirty||_pointBlobStillRendering||(_mapTilesDirty&&(_redrawCountdown===0)))
	{		
		drawMapIntoMainBitmap();				

		_dirty = false;
		_redrawCountdown = 0;
	}
	
	drawMainBitmapIntoViewer();

	if (_hasTabs&&_settings.show_tabs)
	{
		drawTabsIntoViewer();
	}	

	if (_hasTime)
	{
		if (_timelineControls.isPlaying&&!_pointBlobStillRendering)
		{
			var currentTime: Number = new Date().getTime();
			var sinceLastFrame: Number = (currentTime-_lastAnimationFrameTime);
			if ((_settings.max_fps==0)||(sinceLastFrame>(1000/_settings.max_fps)))
			{
				_lastAnimationFrameTime = currentTime;

				_frameIndex += 1;
				if (_frameIndex>=_frameTimes.length)
				{
					_frameIndex = (_frameTimes.length-1);
					_timelineControls.isPlaying = false;
				}
				
				updateTimelineDisplay();
				
				_dirty = true;
				_valuesDirty = true;
				onDataChange();
			}
		}
	}

	drawPopupsIntoViewer();

	if (_onFrameRenderFunction !== null)
		ExternalInterface.call(_onFrameRenderFunction, null);	
}

private function blankWay(): Object
{
	var result: Object = {};
	
	result.boundingBox = new Rectangle();
	result.nds = [];
	result.tags = {};
	result.isClosed = false;
	
	for each (var key:String in _wayDefaults)
	{
		result.tags[key] = _wayDefaults[key];
	}

	return result;	
}

private function onWaysLoad(success:Boolean): void
{ 	  		  	
	var waysData:XML = XML(_waysLoader.data);
  	
  	_tagMap = {};
  	
  	for each (var node: * in waysData..node)
  	{
  		var newNode: Object = {
  				'lon': (Number)(node.@lon),
  				'lat': (Number)(node.@lat)
  		};
  		
  		_nodes[node.@id] = newNode;  		
  	}

  	for each (var way: * in waysData..way)
  	{
		var wayId: String = (String)(way.@id);

  		var newWay: Object = blankWay();
		newWay.id = wayId;
//		newWay.boundingBox = way.bound.@box.explode(',');

		var ndCount: Number = 0;
		var firstNd: String = null;
		var lastNd: String = null;
	  	for each (var nd: * in way..nd)
	  	{
	  		if (typeof _nodes[nd.@ref] === 'undefined')
	  			continue;

	  		ndCount += 1;
	  		newWay.nds.push(nd.@ref);
	  		
	  		if (firstNd===null)
	  			firstNd = nd.@ref;
	  		lastNd = nd.@ref;
	  			  			
	  		var thisNode: Object = _nodes[nd.@ref];
	  		var nodePos: Point = new Point(thisNode.lon, thisNode.lat);
	  		newWay.boundingBox = enlargeBoxToContain(newWay.boundingBox, nodePos);
	  	}
	  	
	  	newWay.isClosed = ((firstNd===lastNd)&&(!_settings.force_outlines));
	  	
	  	for each (var tag: * in way..tag)
	  	{
	  		var key: String = tag.@k;
	  		var value: String = tag.@v;

			if (typeof newWay.tags[key] === 'undefined')
			{
				newWay.tags[key] = value;				
			}
			else
			{
				var oldValue: * = newWay.tags[key];
				if (!(oldValue is Array))
				{
					oldValue = [ oldValue ];
				}
				oldValue.push(value);
	  			newWay.tags[key] = oldValue;
			}
	  		
	  		if (typeof _tagMap[key] === 'undefined')
	  			_tagMap[key] = {};
	  			
	  		if (typeof _tagMap[key][value] === 'undefined')
	  			_tagMap[key][value] = [];
	  			
	  		_tagMap[key][value].push(newWay.id);
	  	}
 
		var layerIndex: Number;
		if (newWay.tags.hasOwnProperty('layer_index'))
			layerIndex = Math.min(16,Math.max(0,(Number)(newWay.tags['layer_index'])));
		else
			layerIndex = 0;
		
		while (_wayLayers.length<=layerIndex)
			_wayLayers.push([]);
		
  		_ways[wayId] = newWay;
  		_wayLayers[layerIndex].push(newWay);
		
  		if (!newWay.boundingBox.isEmpty())
  		{
  			_worldBoundingBox = enlargeBoxToContain(_worldBoundingBox, newWay.boundingBox.topLeft);
  			_worldBoundingBox = enlargeBoxToContain(_worldBoundingBox, newWay.boundingBox.bottomRight);
  		}
  	}

	buildWaysGrid();
	_dirty = true;
	_valuesDirty = true;
	if (_onWaysLoadFunction!==null)
		ExternalInterface.call(_onWaysLoadFunction, _waysFileName);
}
 	  
private function loadWaysFromFile(waysFileName: String): void
{
 	_waysFileName = waysFileName;
    _waysLoader = new URLLoader(new URLRequest(waysFileName));
    _waysLoader.addEventListener("complete", onWaysLoad);
}

private function decodeCSVRow(line: String, columnSeperator: String = ',') : Array
{
	var inQuotes: Boolean = false;
	var inEscape: Boolean = false;
	
	var result: Array = [];

	var currentValue: String = '';

	for( var i: int = 0; i < line.length; i+=1)
	{
		var currentChar: String = line.charAt(i);
	
		if (!inQuotes)
		{
			if (currentChar==='"')
			{
				inQuotes = true;
			}
			else if (currentChar===columnSeperator)
			{
				result.push(currentValue);
				currentValue = '';
			}
			else
			{
				currentValue += currentChar;
			}
		}
		else
		{
			if (!inEscape)
			{
				if (currentChar==='\\')
				{
					inEscape = true;
				}
				else if (currentChar==='"')
				{
					inQuotes = false;
				}
				else
				{
					currentValue += currentChar;
				}
				
			}
			else
			{
				currentValue += currentChar;
				inEscape = false;
			}
			
		}
		
	}
	
	result.push(currentValue);
	
	return result;
}

private function onValuesLoad(success:Boolean): void
{
	loadValuesFromCSVString(_valuesLoader.data.toString());

	if (_onValuesLoadFunction!==null)
		ExternalInterface.call(_onValuesLoadFunction, _valuesFileName);
}

private function loadValuesFromCSVString(valuesString: String): void
{
	var lineSeperator: String = '\n';
	var columnSeperator: String = ',';		  	

	var linesArray: Array = valuesString.split(lineSeperator);
	
	var headerLine: String = linesArray[0];

	_valueHeaders = decodeCSVRow(headerLine, columnSeperator);

	_timeColumnIndex = -1;
	_valueColumnIndex = -1;
	_latitudeColumnIndex = -1;
	_longitudeColumnIndex = -1;
	_tabColumnIndex = -1;
	_tooltipColumnIndex = -1;
	for(var headerIndex:int = 0; headerIndex < _valueHeaders.length; headerIndex++ )
	{
		var header: String = _valueHeaders[headerIndex].toLowerCase();
		if (header==='time')
			_timeColumnIndex = headerIndex;	
		else if (header==='value')
			_valueColumnIndex = headerIndex;
		else if ((header==='latitude')||(header==='lat'))
			_latitudeColumnIndex = headerIndex;
		else if ((header==='longitude')||(header==='lon')||(header==='long'))
			_longitudeColumnIndex = headerIndex;
		else if ((header==='tab')||(header==='category'))
			_tabColumnIndex = headerIndex;
		else if (header==='tooltip')
			_tooltipColumnIndex = headerIndex;
	}
	
	var hasLatitude: Boolean = (_latitudeColumnIndex!==-1);
	var hasLongitude: Boolean = (_longitudeColumnIndex!==-1);
	
	if ((hasLatitude||hasLongitude)&&(hasLatitude!=hasLongitude))
	{
		logError( 'Error loading CSV file "'+_valuesFileName+'" - only found one of longitude or latitude in "'+headerLine+'"');
		return;		
	}
	
	_hasPointValues = hasLatitude;
	_hasTime = (_timeColumnIndex!==-1);
	_hasTabs = (_tabColumnIndex!==-1);
	
	_hasBitmapBackground = _hasPointValues;
	
	if (!_hasPointValues)
		loadAreaValues(linesArray, headerLine, columnSeperator);
	else
		loadPointValues(linesArray, headerLine, columnSeperator);
		
	if (_hasTime)
	{
		calculateFrameTimes();
		_frameIndex = 0;
		addTimelineControls();
	}
	
	_valuesDirty = true;
	_dirty = true;			
}

private function loadValuesFromFile(valuesFileName: String): void
{
	_valuesFileName = valuesFileName;
	_valuesLoader = new URLLoader(new URLRequest(valuesFileName));
	_valuesLoader.addEventListener("complete", onValuesLoad);
}

private function drawInformationLayer(graphics: Graphics, width: Number, height: Number, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): void
{    
    var viewingArea: Rectangle = calculateViewingArea(width, height, xYToLatLonMatrix);

    var bitmapBackground: BitmapData = drawBackgroundBitmap(width, height, viewingArea, latLonToXYMatrix, xYToLatLonMatrix);
	
	drawWays(graphics, width, height, viewingArea, latLonToXYMatrix, bitmapBackground);
}

private function drawWays(graphics: Graphics, width: Number, height: Number, viewingArea: Rectangle, latLonToXYMatrix: Matrix, bitmapBackground: BitmapData): void
{
	var hasBitmap: Boolean = (bitmapBackground!==null);
	var bitmapMatrix: Matrix = new Matrix();
	if ((_settings.point_drawing_shape=='blob')||(_settings.is_value_distance))
		bitmapMatrix.scale(_settings.point_bitmap_scale, _settings.point_bitmap_scale);
	
	var waysEmpty: Boolean = true;
	for (var wayId:String in _ways)
	{
		waysEmpty = false;
		break;
	}
	
	if (hasBitmap&&waysEmpty)
	{
		graphics.lineStyle();
		graphics.beginBitmapFill(bitmapBackground, bitmapMatrix, false, true);

		graphics.moveTo(0, 0);
		graphics.lineTo(width, 0);
		graphics.lineTo(width, height);
		graphics.lineTo(0, height);
		graphics.lineTo(0, 0);
		
		graphics.endFill();
				
		return;
	}

	for (var layerIndex: * in _wayLayers)
	{
		for each (var way: Object in _wayLayers[layerIndex])
		{
			var wayColor: Number;
			var wayAlpha: Number;
			if (getWayProperty('highlighted', way.tags)==true)
			{
				wayColor = Number(getWayProperty('highlightColor', way.tags));
				wayAlpha = Number(getWayProperty('highlightAlpha', way.tags));
			}
			else
			{
				wayColor = Number(getWayProperty('color', way.tags));
				wayAlpha = Number(getWayProperty('alpha', way.tags));
			}
			
			if (way.nds.length<1)
				continue;
			
			if (!viewingArea.intersects(way.boundingBox))
				continue;
	
			var isClosed: Boolean = way.isClosed;
	
			if (isClosed)
			{
				var finalNd: String = way.nds[way.nds.length-1];
				var finalNode: Object = _nodes[finalNd];
				
				var finalPos: Point = getXYFromLatLon(finalNode, latLonToXYMatrix);

				var lineColor: Number = Number(getWayProperty('line_color', way.tags))
				var lineAlpha: Number = Number(getWayProperty('line_alpha', way.tags))
				var lineThickness: Number = Number(getWayProperty('line_thickness', way.tags))
				
				if (lineAlpha<0.01)
					graphics.lineStyle();
				else
					graphics.lineStyle(lineThickness, lineColor, lineAlpha);
					
				if (hasBitmap)
					graphics.beginBitmapFill(bitmapBackground, bitmapMatrix, false, true);
				else
					graphics.beginFill(wayColor, wayAlpha);
				
				graphics.moveTo(finalPos.x, finalPos.y);
			}
			else
			{
				var firstNd: String = way.nds[0];
				var firstNode: Object = _nodes[firstNd];
				
				var firstPos: Point = getXYFromLatLon(firstNode, latLonToXYMatrix);
	
				graphics.lineStyle(0, wayColor,wayAlpha);
	
				graphics.moveTo(firstPos.x, firstPos.y);
			}
	
			for each (var currentNd: String in way.nds)
			{
				var currentNode: Object = _nodes[currentNd];
				var currentPos: Point = getXYFromLatLon(currentNode, latLonToXYMatrix);
				
				graphics.lineTo(currentPos.x, currentPos.y);
			}
	
			if (isClosed)
			{
				graphics.endFill();
			}
		}
	}

}

private function setWaysFromValues(): void
{	
	if (_valueData === null)
		return;

	if (_settings.is_gradient_value_range_set)
	{
		var minValue: Number = _settings.gradient_value_min;
		var maxValue: Number = _settings.gradient_value_max;	
	}
	else
	{
		minValue = _smallestValue;
		maxValue = _largestValue;
	}
	if (Math.abs(maxValue-minValue)<0.00001)	
		minValue = (maxValue-1.0);
	var valueScale: Number = (1/(maxValue-minValue));
	
	var currentValues: Array = getCurrentValues();
	
	var thisSetWayIds: Object = {};
	
	if (_hasTime)
		var currentTime: String = _frameTimes[_frameIndex];
	
	for (var valuesIndex: * in currentValues)
	{
		var values: Array = currentValues[valuesIndex];
		
		if (_hasTime)
		{
			var thisTime: String = values[_timeColumnIndex];
			if (thisTime !== currentTime)
				continue;
		}

		var matchKeys: Object = {};
		var thisValue: Number = 0;		
		for (var i:int = 0; i<values.length; i+=1)
		{
			if (i===_valueColumnIndex)
			{
				thisValue = (Number)(values[i]);
			}
			else if ((i!==_timeColumnIndex)&&(i!==_tabColumnIndex)&&(i!==_tooltipColumnIndex))
			{
				var headerName: String = _valueHeaders[i];
				matchKeys[headerName] = values[i];	
			}
		}
		
		var setColor: uint = getColorForValue(thisValue, minValue, maxValue, valueScale);
		setColor = (setColor & 0x00ffffff);
		
		setAttributeForMatchingWays(matchKeys, 'color', (String)(setColor), thisSetWayIds, valuesIndex);
	}

	if (_settings.clear_ways)
	{		
		var defaultColor: String = (String)(getWayProperty('color'));
		
		for (var lastWayId: String in _lastSetWayIds)
		{
			if (thisSetWayIds.hasOwnProperty(lastWayId))
				continue;
				
			_ways[lastWayId]['tags']['color'] = defaultColor;
		}
	}
	
	_lastSetWayIds = thisSetWayIds;
}

private function setColorGradient(colorList: Array) : void
{
	_colorGradient = [];
	
	for each (var colorString: String in colorList)
	{
		colorString = colorString.replace('#', '0x');
		
		var colorNumber: uint = (uint)(colorString);
		
		var alpha: uint;
		if (colorString.length>8)
			alpha = (colorNumber>>24)&0xff;
		else
			alpha = 0x7f;		
		
		var red: uint = (colorNumber>>16)&0xff;
		var green: uint = (colorNumber>>8)&0xff;
		var blue: uint = (colorNumber>>0)&0xff;
		
		var premultRed: uint = Math.floor((red*alpha)/255.0);
		var premultGreen: uint = Math.floor((green*alpha)/255.0);
		var premultBlue: uint = Math.floor((blue*alpha)/255.0);
		
		_colorGradient.push({
			alpha: alpha,
			red: premultRed,
			green: premultGreen,
			blue: premultBlue
		});
	}

	_valuesDirty = true;
	_redrawCountdown = 5;
}

private function setAttributeForMatchingWays(matchKeys: Object, attributeName: String, attributeValue: String, setWays: Object, valueIndex: int) : void
{
	var matchingWayIds: Object = null;
	for (var key:String in matchKeys)
	{
		var value: String = matchKeys[key];
		
		var currentMatches: Array;
		if (!_tagMap.hasOwnProperty(key)||!_tagMap[key].hasOwnProperty(value))
			currentMatches = [];
		else
		 	currentMatches = _tagMap[key][value];
		 
		if (matchingWayIds === null)
		{
			matchingWayIds = {};
			for each (var wayId: String in currentMatches)
				matchingWayIds[wayId] = true;
		}
		else
		{
			var previousMatchingWayIds: Object = matchingWayIds;
			matchingWayIds = {};
			for each (wayId in currentMatches)
			{
				if (typeof previousMatchingWayIds[wayId] !== 'undefined')
					matchingWayIds[wayId] = true;
			}
		}
	}
		
	var foundCount: Number = 0;
	for (wayId in matchingWayIds)
	{
		var wayTags: Object = _ways[wayId]['tags'];
		wayTags[attributeName] = attributeValue;
		wayTags['valueIndex'] = valueIndex;
		foundCount += 1;
		setWays[wayId] = true;
	}

//	if (foundCount===0)
//	{
//		trace('No match found for');
//		for (key in matchKeys)
//		{
//			value = matchKeys[key];	
//			trace(key+':'+value);
//		}
//	}

}

private function enlargeBoxToContain(box: Rectangle, pos: Point): Rectangle
{
	if (box.containsPoint(pos))
		return box;
	
	if ((box.x==0)&&
		(box.y==0)&&
		(box.width==0)&&
		(box.height==0))
		return new Rectangle(pos.x, pos.y, 0, 0);
		
	if (box.left>pos.x)
		box.left = pos.x;

	if (box.right<pos.x)
		box.right = pos.x;

	if (box.top>pos.y)
		box.top = pos.y;
		
	if (box.bottom<pos.y)
		box.bottom = pos.y;
		
	return box;
}

private function buildWaysGrid(): void
{
	_waysGrid = new BucketGrid(_worldBoundingBox, 16, 16);
	
	for (var wayId:String in _ways)
	{
		var way: Object = _ways[wayId];

		var boundingBox: Rectangle = way.boundingBox;
		if (boundingBox.isEmpty())
			continue;
		
		_waysGrid.insertObjectAt(boundingBox, wayId);
	}
}

private function getWaysContainingLatLon(lat: Number, lon: Number): Array
{
	var result: Array = new Array();

	var pos: Point = new Point(lon, lat);

	if (!_worldBoundingBox.containsPoint(pos))
		return result;
	
	if (_waysGrid===null)
		return result;
	
	var pixelsPerDegree: Number = getPixelsPerDegreeLatitude();
	var pixelsToDegreeScale: Number = (1.0/pixelsPerDegree);
	var ways: Array = _waysGrid.getContentsAtPoint(pos);

	var currentValues: Array = getCurrentValues();
	
	for each (var wayId: String in ways)
	{
		var way: Object = _ways[wayId];
		var isInside: Boolean = false;
		if (way.isClosed)
		{
			if (way.boundingBox.containsPoint(pos))
			{
				isInside = isPointInsideClosedWay(pos, way);
			}
		}
		else
		{
			var lineThickness: Number = (Number)(getWayProperty('line_thickness', way.tags));
			
			var thicknessInDegrees: Number = Math.abs((lineThickness+1)*pixelsToDegreeScale);
			
			var boundingBox: Rectangle = way.boundingBox.clone();
//			boundingBox.inflate(thicknessInDegrees/2, thicknessInDegrees/2);
			
			if (boundingBox.containsPoint(pos))
			{
				isInside = isPointOnWayLine(pos, way, thicknessInDegrees);	
			}			
		}
		
		if (isInside)
		{
			var wayResult: Object = {};
			wayResult.id = wayId;
			wayResult.tags = {};

			if (typeof way.tags['valueIndex'] != 'undefined')
			{			
				var valueIndex: int = way.tags['valueIndex'];
				var valuesRow: Array = currentValues[valueIndex];
	
				for(var headerIndex:int = 0; headerIndex < _valueHeaders.length; headerIndex++ )
				{
					var header: String = '"'+_valueHeaders[headerIndex].toLowerCase()+'"';
					
					wayResult.tags[header] = valuesRow[headerIndex];
				}
			}
				
			for (var key: String in way.tags)
			{
				// Pete - Safari really doesn't like colons in member names! 
				key = key.replace(':', '_colon_');
				var value: String = way.tags[key];
				wayResult.tags[key] = value;
			}
			
			result.push(wayResult);
		}
	}
	
	return result;
}

private function addTimelineControls(): void
{
	if (_timelineControls === null)
	{
		_timelineControls = new TimelineControls();
		_timelineControls.percentWidth = 100;
		_timelineControls.setWidth(_settings.width-250);
		
		var verticalCenter: Number = ((_settings.height/2)-40);
		_timelineControls.y = (_settings.height-50);
	
		_timelineControls.setTimeTextStyle(18, 0x000000);
		
		_timelineControls.setOnUserInputCallback(onTimelineUserInput);
	
		addChild(this._timelineControls);
	}
	
	updateTimelineDisplay();
}

private function onTimelineUserInput(dragging: Boolean, playClick: Boolean): void
{
	var sliderValue: Number = _timelineControls.sliderValue;

	var totalFrames: int = _frameTimes.length;

	_frameIndex = Math.round(sliderValue*(totalFrames-1));
	_frameIndex = Math.min(_frameIndex, (totalFrames-1));
	_frameIndex = Math.max(_frameIndex, 0);
	
	if (playClick&&(_frameIndex==(totalFrames-1)))
	{
		_frameIndex = 0;
	}
		
	updateTimelineDisplay();
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
		
	_valuesDirty = true;
	onDataChange();
}

private function updateTimelineDisplay(): void
{
	if (_frameTimes.length>0)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		_timelineControls.timeText = currentTime;
		
		var totalFrames: int = _frameTimes.length;
		_timelineControls.sliderValue = (_frameIndex/(totalFrames-1));
	}
}

private function getValueForWayId(wayId: String): String
{
	if (typeof _ways[wayId] === 'undefined')
		return null;
		
	var way: Object = _ways[wayId];

	if (_valueData === null)
		return null;

	var currentValues: Array = getCurrentValues();
	
	var resultFound: Boolean = false;
	var result: String;
	for each (var values: Array in currentValues)
	{
		var matchKeys: Object = {};
		var thisValue: String = null;		
		for (var i:int = 0; i<values.length; i+=1)
		{
			if (i===_valueColumnIndex)
			{
				thisValue = values[i]; 
			}
			else if ((i!==_timeColumnIndex)&&(i!==_tabColumnIndex)&&(i!==_tooltipColumnIndex))
			{
				var headerName: String = _valueHeaders[i];
				matchKeys[headerName] = values[i];	
			}
		}
		
		var allMatch: Boolean = true;
		var emptyMatchKeys: Boolean = true;
		for (var key: String in matchKeys)
		{
			var value:String = matchKeys[key];
			
			var wayValue: * = way.tags[key];
			if (wayValue is Array)
			{
				var anyMatch: Boolean = false;
				for (var wayValueIndex: int = 0; wayValueIndex<wayValue.length; wayValueIndex+=1)
				{
					var subValue: String = wayValue[wayValueIndex];
					if (subValue==value)
						anyMatch = true;
				}
				if (!anyMatch)
					allMatch = false;
			}
			else
			{
				if (way.tags[key]!==value)
					allMatch = false;
			}
			
			emptyMatchKeys = false;
		}
		
		if (allMatch && !emptyMatchKeys)
		{
			resultFound = true;
			result = thisValue;
		}
	}

	if (resultFound)
		return result;
	else
		return null;
}

private function addInlay(leftX: Number, topY: Number, rightX: Number, bottomY: Number, topLat: Number, leftLon: Number, bottomLat: Number, rightLon: Number): void
{
	var mercatorTopLat: Number = latitudeToMercatorLatitude(topLat);
	var mercatorBottomLat: Number = latitudeToMercatorLatitude(bottomLat);
	
	var width: Number = (rightX-leftX);
	var height: Number = (bottomY-topY);
	
	var widthLon: Number = (rightLon-leftLon);
	var heightLat: Number = (mercatorBottomLat-mercatorTopLat);
	
	var scaleX: Number = (width/widthLon);
	var scaleY: Number = (height/heightLat);

	var latLonToXYMatrix: Matrix = new Matrix();
	latLonToXYMatrix.translate(-leftLon, -mercatorTopLat);
	latLonToXYMatrix.scale(scaleX, scaleY);	

	var xYToLatLonMatrix: Matrix = latLonToXYMatrix.clone();
	xYToLatLonMatrix.invert();
	
	var worldTopLeftLatLon: Object = getLatLonFromXY(new Point(leftX, topY), _xYToLatLonMatrix);
	var worldBottomRightLatLon: Object = getLatLonFromXY(new Point(rightX, bottomY), _xYToLatLonMatrix);
	
	_inlays.push({
		latLonToXYMatrix: latLonToXYMatrix,
		xYToLatLonMatrix: xYToLatLonMatrix,
		worldTopLeftLatLon: worldTopLeftLatLon,
		worldBottomRightLatLon: worldBottomRightLatLon,
		topLat: topLat,
		leftLon: leftLon,
		bottomLat: bottomLat,
		rightLon: rightLon
	});
}

private function cropPoint(input: Point, area: Rectangle): Point
{
	var result: Point = input.clone();
	
	if (result.x<area.left)
		result.x = area.left;
	
	if (result.x>area.right)
		result.x = area.right;	
	
	if (result.y<area.top)
		result.y = area.top;
	
	if (result.y>area.bottom)
		result.y = area.bottom;	

	return result;	
}

private function drawMapIntoMainBitmap(): void
{
	_mainShape.graphics.clear();

	if (_settings.show_map_tiles)
	{
		trackMapTilesUsage();
		drawMapTiles(_mainShape.graphics, _settings.width, _settings.height, _latLonToXYMatrix, _xYToLatLonMatrix);
	}

	if (_dirty||_pointBlobStillRendering)
	{			
		_informationLayerShape.graphics.clear();
		drawInformationLayer(_informationLayerShape.graphics, _settings.width, _settings.height, _latLonToXYMatrix, _xYToLatLonMatrix);
		_informationLayerBitmap.bitmapData.fillRect(new Rectangle(0, 0, width, height), 0x00000000);
		_informationLayerBitmap.bitmapData.draw(_informationLayerShape, new Matrix());
	}
	
	_mainShape.graphics.beginBitmapFill(_informationLayerBitmap.bitmapData, new Matrix(), false);
	_mainShape.graphics.drawRect(0, 0, _settings.width, _settings.height);
	_mainShape.graphics.endFill();	
			
	for each (var inlay: Object in _inlays)
	{
		var screenTopLeft: Point = getXYFromLatLon(inlay.worldTopLeftLatLon, _latLonToXYMatrix);
		var screenBottomRight: Point = getXYFromLatLon(inlay.worldBottomRightLatLon, _latLonToXYMatrix);
		
		var screenArea: Rectangle = new Rectangle(0, 0, _settings.width, _settings.height);
		
		var croppedScreenTopLeft: Point = cropPoint(screenTopLeft, screenArea);
		var croppedScreenBottomRight: Point = cropPoint(screenBottomRight, screenArea);
		
		var inlayWidth: Number = (croppedScreenBottomRight.x-croppedScreenTopLeft.x);
		var inlayHeight: Number = (croppedScreenBottomRight.y-croppedScreenTopLeft.y);
		
		if ((inlayWidth<1)||(inlayHeight<1))
			continue;
		
		var inlayScreenLeftX: Number = croppedScreenTopLeft.x;
		var inlayScreenTopY: Number = croppedScreenTopLeft.y;
		
		var localTopLeft: Point = croppedScreenTopLeft.subtract(screenTopLeft);

		var croppedLatLonToXYMatrix: Matrix = inlay.latLonToXYMatrix.clone();
		croppedLatLonToXYMatrix.translate(-localTopLeft.x, -localTopLeft.y);
		
		var croppedXYToLatLonMatrix: Matrix = croppedLatLonToXYMatrix.clone();
		croppedXYToLatLonMatrix.invert();
		
		var drawingSurface: Shape = new Shape();
		var bitmapData:BitmapData = new BitmapData(inlayWidth, inlayHeight, true, (_settings.ocean_color|0xff000000));
		
		if (_settings.show_map_tiles)	
			drawMapTiles(drawingSurface.graphics, inlayWidth, inlayHeight, croppedLatLonToXYMatrix, croppedXYToLatLonMatrix);

		if (_dirty||_pointBlobStillRendering)
		{
			inlay._informationLayerShape = new Shape();
			var informationBitmapData:BitmapData = new BitmapData(inlayWidth, inlayHeight, true, _settings.ocean_color);
			inlay._informationLayerBitmap = new Bitmap(informationBitmapData);
			inlay._informationLayerBitmap.x = 0;
			inlay._informationLayerBitmap.y = 0;
			
			inlay._informationLayerShape.graphics.clear();
			drawInformationLayer(inlay._informationLayerShape.graphics, inlayWidth, inlayHeight, croppedLatLonToXYMatrix, croppedXYToLatLonMatrix);
			inlay._informationLayerBitmap.bitmapData.fillRect(new Rectangle(0, 0, inlayWidth, inlayHeight), 0x00000000);
			inlay._informationLayerBitmap.bitmapData.draw(inlay._informationLayerShape, new Matrix());
		}
		
		drawingSurface.graphics.beginBitmapFill(inlay._informationLayerBitmap.bitmapData, new Matrix(), false);
		drawingSurface.graphics.drawRect(0, 0, inlayWidth, inlayHeight);
		drawingSurface.graphics.endFill();
		
		var borderTopLeft: Point = screenTopLeft.subtract(croppedScreenTopLeft);
		var borderBottomRight: Point = screenBottomRight.subtract(croppedScreenTopLeft).subtract(new Point(1, 1));
		
		borderTopLeft.x = Math.floor(borderTopLeft.x);
		borderTopLeft.y = Math.floor(borderTopLeft.y);
		
		borderBottomRight.x = Math.floor(borderBottomRight.x);
		borderBottomRight.y = Math.floor(borderBottomRight.y);
		
		if (_settings.show_map_tiles)
		{
			drawingSurface.graphics.lineStyle(1, _settings.inlay_border_color, 1.0);
			drawingSurface.graphics.moveTo(borderTopLeft.x, borderTopLeft.y);
			drawingSurface.graphics.lineTo(borderBottomRight.x, borderTopLeft.y);
			drawingSurface.graphics.lineTo(borderBottomRight.x, borderBottomRight.y);
			drawingSurface.graphics.lineTo(borderTopLeft.x, borderBottomRight.y);
			drawingSurface.graphics.lineTo(borderTopLeft.x, borderTopLeft.y);
		}
		
		bitmapData.draw(drawingSurface, new Matrix());

		var inlayMatrix: Matrix = new Matrix();
		inlayMatrix.translate(inlayScreenLeftX, inlayScreenTopY);

		_mainShape.graphics.beginBitmapFill(bitmapData, inlayMatrix, false);
		_mainShape.graphics.drawRect(inlayScreenLeftX, inlayScreenTopY, inlayWidth, inlayHeight);
		_mainShape.graphics.endFill();
	}

	_mainBitmap.bitmapData.fillRect(new Rectangle(0, 0, _settings.width, _settings.height), _settings.ocean_color);
	_mainBitmap.bitmapData.draw(_mainShape, new Matrix());
	
	_mainBitmapTopLeftLatLon = getLatLonFromXY(new Point(0, 0), _xYToLatLonMatrix);
	_mainBitmapBottomRightLatLon = getLatLonFromXY(new Point(_settings.width, _settings.height), _xYToLatLonMatrix);

	if (_settings.show_map_tiles)
	{
		deleteUnusedMapTiles();
	}
}

private function drawMainBitmapIntoViewer(): void
{
	viewer.graphics.clear();
	
	if ((_mainBitmapTopLeftLatLon===null)||
		(_mainBitmapBottomRightLatLon===null))
		return;
		
	var screenBitmapTopLeft: Point = getXYFromLatLon(_mainBitmapTopLeftLatLon, _latLonToXYMatrix);
	var screenBitmapBottomRight: Point = getXYFromLatLon(_mainBitmapBottomRightLatLon, _latLonToXYMatrix);	

	var screenBitmapLeft: Number = screenBitmapTopLeft.x;
	var screenBitmapTop: Number = screenBitmapTopLeft.y;
	
	var screenBitmapWidth: Number = (screenBitmapBottomRight.x-screenBitmapTopLeft.x);
	var screenBitmapHeight: Number = (screenBitmapBottomRight.y-screenBitmapTopLeft.y);
	
	var bitmapTransform: Matrix = new Matrix();
	bitmapTransform.scale((screenBitmapWidth/_settings.width), (screenBitmapHeight/_settings.height));
	bitmapTransform.translate(screenBitmapLeft, screenBitmapTop);
	
	viewer.graphics.beginBitmapFill(_mainBitmap.bitmapData, bitmapTransform, false);
	viewer.graphics.drawRect(screenBitmapLeft, screenBitmapTop, screenBitmapWidth, screenBitmapHeight);
	viewer.graphics.endFill();	
}

private function translateMapByScreenPixels(x: Number, y: Number, dragging: Boolean = false): void
{
	_latLonToXYMatrix.translate(x, y);
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
}

private function zoomMapByFactorAroundPoint(zoomFactor: Number, center: Point, dragging: Boolean = false): void
{
	var translateToOrigin: Matrix = new Matrix();
	translateToOrigin.translate(-center.x, -center.y);
	
	var scale: Matrix = new Matrix();
	scale.scale(zoomFactor, zoomFactor);
	
	var translateFromOrigin: Matrix = new Matrix();
	translateFromOrigin.translate(center.x, center.y);

	var zoom: Matrix = new Matrix();
	zoom.concat(translateToOrigin);
	zoom.concat(scale);
	zoom.concat(translateFromOrigin);
	
	_latLonToXYMatrix.concat(zoom);
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();

	for each (var inlay: Object in _inlays)
	{
		var newLatLonToXYMatrix: Matrix = inlay.latLonToXYMatrix.clone();
		newLatLonToXYMatrix.concat(scale);
		
		var newXYToLatLonMatrix: Matrix = newLatLonToXYMatrix.clone();
		newXYToLatLonMatrix.invert();
		
		inlay.latLonToXYMatrix = newLatLonToXYMatrix;
		inlay.xYToLatLonMatrix = newXYToLatLonMatrix;
	}
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
		
	updateZoomSliderDisplay();
}

private function createViewerElements(): void
{
	_mainShape = new Shape();
	var bitmapData:BitmapData = new BitmapData(width, height, false, _settings.ocean_color);
	_mainBitmap = new Bitmap(bitmapData);
	_mainBitmap.x = 0;
	_mainBitmap.y = 0;

	_informationLayerShape = new Shape();
	var informationBitmapData:BitmapData = new BitmapData(width, height, true, _settings.ocean_color);
	_informationLayerBitmap = new Bitmap(informationBitmapData);
	_informationLayerBitmap.x = 0;
	_informationLayerBitmap.y = 0;
		
	_credit = new Label();
	_credit.htmlText = _settings.credit_text;
	_credit.width = 150;
	_credit.height = 20;
	_credit.setStyle('text-align', 'right');
	_credit.setStyle('color', _settings.credit_color);
	_credit.setStyle('fontFamily', 'Baskerville, Georgia, Times New Roman, Serif');
	
    _credit.addEventListener( MouseEvent.CLICK, function(): void {
    	var url:String = "http://"+_credit.text;
		if (_credit.text=='OpenHeatMap')
			url = 'http://www.openheatmap.com/';
        var request:URLRequest = new URLRequest(url);
		navigateToURL(request); 	  	
 	});
	
	viewer.addChild(_credit);

	_title = new TextField();
	_title.htmlText = '<p align="center"><u>'+_settings.title_text+'</u></p>';
	_title.width = _settings.width;
	_title.height = (_settings.title_size*1.5);
	_title.textColor = _settings.title_color;
	_title.background = true;
	_title.backgroundColor = _settings.title_background_color;
//	_title.fontSize = _settings.title_size;
	_title.y = -1000;

	var titleFormat: TextFormat = _title.defaultTextFormat;
	titleFormat.size = _settings.title_size;
	titleFormat.font = 'Baskerville';
	_title.defaultTextFormat = titleFormat;
	
	viewer.addChild(_title);

	repositionMoveableElements();
}

private function onZoomThumbDrag( event: SliderEvent ): void
{
	var pixelsPerDegreeLatitude: Number = calculatePixelsPerDegreeLatitudeFromZoomSlider();
	
	setPixelsPerDegreeLatitude(pixelsPerDegreeLatitude, true);

	onViewChange();
}

private function onZoomThumbRelease( event: SliderEvent ): void
{
	var pixelsPerDegreeLatitude: Number = calculatePixelsPerDegreeLatitudeFromZoomSlider();
	
	setPixelsPerDegreeLatitude(pixelsPerDegreeLatitude, false);	

	onViewChange();
}

private function getPixelsPerDegreeLatitude(): Number
{
	var pixelsPerDegreeLatitude: Number = _latLonToXYMatrix.d;
	
	return pixelsPerDegreeLatitude;
}

private function setPixelsPerDegreeLatitude(newPixelsPerDegreeLatitude: Number, dragging: Boolean = false): void
{
	var oldPixelsPerDegreeLatitude: Number = getPixelsPerDegreeLatitude();
	
	var zoomFactor: Number = (newPixelsPerDegreeLatitude/oldPixelsPerDegreeLatitude);
	
	var center: Point = new Point((_settings.width/2), (_settings.height/2));
	
	zoomMapByFactorAroundPoint(zoomFactor, center, dragging);
}

private function calculatePixelsPerDegreeLatitudeFromZoomSlider(): Number
{
	var sliderValue: Number = _zoomSlider.value;
	
	var lerpValue: Number = Math.pow(sliderValue, _settings.zoom_slider_power);

	var minPixelsPerDegreeLatitude: Number = (_settings.height/_settings.zoomed_out_degrees_per_pixel);
	var maxPixelsPerDegreeLatitude: Number = (_settings.height/_settings.zoomed_in_degrees_per_pixel);

	var oneMinusLerp: Number = (1-lerpValue);
	
	var result: Number = (minPixelsPerDegreeLatitude*oneMinusLerp)+
		(maxPixelsPerDegreeLatitude*lerpValue);
	
	return result;
}

private function updateZoomSliderDisplay(): void
{
	if (_zoomSlider == null)
		return;
	
	var pixelsPerDegreeLatitude: Number = getPixelsPerDegreeLatitude();

	var minPixelsPerDegreeLatitude: Number = (_settings.height/_settings.zoomed_out_degrees_per_pixel);
	var maxPixelsPerDegreeLatitude: Number = (_settings.height/_settings.zoomed_in_degrees_per_pixel);

	var lerpValue: Number = ((pixelsPerDegreeLatitude-minPixelsPerDegreeLatitude)/
		(maxPixelsPerDegreeLatitude-minPixelsPerDegreeLatitude));
	
	var sliderValue: Number = Math.pow(lerpValue, (1/_settings.zoom_slider_power));

	_zoomSlider.value = sliderValue;
}

private function setGradientValueRange(min: Number, max: Number): void
{
	_settings.is_gradient_value_range_set = true;
	_settings.gradient_value_min = min;
	_settings.gradient_value_max = max;
}

private function calculateFrameTimes(): void
{
	_frameTimes = [];
	
	for (var thisTime: String in _foundTimes)
	{
		if ((_settings.time_range_start!==null)&&(thisTime<_settings.time_range_start))
			continue;

		if ((_settings.time_range_end!==null)&&(thisTime>_settings.time_range_end))
			continue;
		
		_frameTimes.push(thisTime);
	}
	_frameTimes.sort();
	
	if (_frameIndex>(_frameTimes.length-1))
		_frameIndex = (_frameTimes.length-1);
}

private function onDataChange(): void
{
	if (_onDataChangeFunction!==null)
		ExternalInterface.call(_onDataChangeFunction, null);	
}

private function logError(message: String): void
{
	trace('Error: '+message);
	if (_onErrorFunction!==null)
		ExternalInterface.call(_onErrorFunction, message);	
}

private function onViewChange(): void
{
	if (_onViewChangeFunction!==null)
		ExternalInterface.call(_onViewChangeFunction, null);	
}

private function getWayForWayId(wayId: String): Object
{
	var result: Object = _ways[wayId];
	
	return result;	
}

private function isPointInsideClosedWay(pos: Point, way: Object): Boolean
{
	var xIntersections: Array = [];

	var lineStart: Point = null;
	var isFirst: Boolean = true;
	
	for each (var currentNd: String in way.nds)
	{
		var currentNode: Object = _nodes[currentNd];
		var lineEnd: Point = new Point(currentNode.lon, currentNode.lat);
		
		if (isFirst)
		{
			isFirst = false;
		}
		else
		{
			if (((lineStart.y>pos.y)&&(lineEnd.y<pos.y))||
				((lineStart.y<pos.y)&&(lineEnd.y>pos.y)))
			{
				var lineDirection: Point = new Point(lineEnd.x-lineStart.x, lineEnd.y-lineStart.y);
				var yDelta: Number = (pos.y-lineStart.y);
				var yProportion: Number = (yDelta/lineDirection.y);
				
				var xIntersect: Number = (lineStart.x+(lineDirection.x*yProportion));
				xIntersections.push(xIntersect);
			}
			
		}
		
		lineStart = lineEnd;
	}
	
	xIntersections.sort(function(a:Number, b:Number): int {
		if (a<b) return -1;
		else if (a>b) return 1;
		else return 0; 
	});
	
	var isInside: Boolean = false;
	for (var index: int = 0; index<(xIntersections.length-1); index += 2)
	{
		var leftX: Number = xIntersections[index];
		var rightX: Number = xIntersections[(index+1)];

		if ((leftX<=pos.x)&&(rightX>pos.x))
			isInside = true;
		
	}
				
	return isInside;
}

private function isPointOnWayLine(pos: Point, way: Object, thickness: Number): Boolean
{
	var lineStart: Point = null;
	var isFirst: Boolean = true;
	
	var thicknessSquared: Number = (thickness*thickness);
	
	var isInside: Boolean = false;
	for each (var currentNd: String in way.nds)
	{
		var currentNode: Object = _nodes[currentNd];
		var lineEnd: Point = new Point(currentNode.lon, currentNode.lat);
		
		if (isFirst)
		{
			isFirst = false;
		}
		else
		{
			var lineDirection: Point = new Point(lineEnd.x-lineStart.x, lineEnd.y-lineStart.y);
			
			var lineDirectionSquared: Number = ((lineDirection.x*lineDirection.x)+(lineDirection.y*lineDirection.y));
			
			var s: Number = ((pos.x-lineStart.x)*lineDirection.x)+((pos.y-lineStart.y)*lineDirection.y);
			s /= lineDirectionSquared;
			
			s = Math.max(s, 0);
			s = Math.min(s, 1);
			
			var closestPoint: Point = new Point((lineStart.x+s*lineDirection.x), (lineStart.y+s*lineDirection.y));
			
			var delta: Point = pos.subtract(closestPoint);
			
			var distanceSquared: Number = ((delta.x*delta.x)+(delta.y*delta.y));
			
			if (distanceSquared<thicknessSquared)
			{
				isInside = true;
				break;
			}
		}
		
		lineStart = lineEnd;
	}
	
				
	return isInside;
}

private function drawPointBlobBitmap(width: Number, height: Number, viewingArea: Rectangle, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): BitmapData
{		
	if (_dirty)
	{
		createPointsGrid(viewingArea, latLonToXYMatrix);
	
		_pointBlobBitmapWidth = (width/_settings.point_bitmap_scale);
		_pointBlobBitmapHeight = (height/_settings.point_bitmap_scale);
	
		_pointBlobBitmap = new BitmapData(_pointBlobBitmapWidth, _pointBlobBitmapHeight, true, 0x000000);
		
		_pointBlobTileX = 0;
		_pointBlobTileY = 0;
		
		_pointBlobStillRendering = true;
	}

	var tileSize: int = _settings.point_blob_tile_size;	
	
	var startTime: Number = new Date().getTime();
	
	while (_pointBlobTileY<_pointBlobBitmapHeight)
	{
		var distanceFromBottom: int = (_pointBlobBitmapHeight-_pointBlobTileY);
		var tileHeight: int = Math.min(tileSize, distanceFromBottom);
		
		while (_pointBlobTileX<_pointBlobBitmapWidth)
		{	
			var distanceFromRight: int = (_pointBlobBitmapWidth-_pointBlobTileX);
			var tileWidth: int = Math.min(tileSize, distanceFromRight);
			
			drawPointBlobTile(width, height, viewingArea, latLonToXYMatrix, xYToLatLonMatrix, _pointBlobTileX, _pointBlobTileY, tileWidth, tileHeight);
			
			_pointBlobTileX+=tileSize;

			var currentTime: Number = new Date().getTime();
			var sinceStart: Number = (currentTime-startTime);
			
			if ((_timelineControls===null)||(!_timelineControls.isPlaying))
			{
				if (sinceStart>2000)
					return _pointBlobBitmap;
			}
		}
		
		_pointBlobTileX = 0;
		_pointBlobTileY+=tileSize
	}
	
	_pointBlobStillRendering = false;
	
	return _pointBlobBitmap;
}

private function loadAreaValues(linesArray: Array, headerLine: String, columnSeperator: String): void
{
	if (_valueColumnIndex===-1)
	{
		logError( 'Error loading CSV file "'+_valuesFileName+'" - missing value column from header "'+headerLine+'"');
		return;
	}
	
	_foundTimes = {};
	_tabNames = [];
	_tabInfo = {};
	
	_valueData = [];
	
	for(var i : int = 1; i < linesArray.length; i++ )
	{
		var lineString: String = linesArray[i];
		var lineValues: Array = decodeCSVRow(lineString, columnSeperator);
		
		var thisValue: Number = (Number)(lineValues[_valueColumnIndex]);
		
		if ((i===1)||(thisValue<_smallestValue))
			_smallestValue = thisValue;
			
		if ((i===1)||(thisValue>_largestValue))
			_largestValue = thisValue;
		
		var dataDestination: Array = _valueData;

		if (_hasTabs)
		{
			var thisTab: String = lineValues[_tabColumnIndex];
			if (thisTab !== null)
			{
				if (typeof _tabInfo[thisTab] === 'undefined')
				{
					_tabInfo[thisTab] = {};
					_tabNames.push(thisTab);
				}
				
				if (typeof dataDestination[thisTab]==='undefined')
				{
					dataDestination[thisTab] = [];
				}
				
				dataDestination = dataDestination[thisTab];
			}			
		}		
		
		if (_hasTime)
		{
			var thisTime: String = lineValues[_timeColumnIndex];
			if ((thisTime !== null)&&(thisTime!=''))
			{
				if (typeof _foundTimes[thisTime] === 'undefined')
				{
					_foundTimes[thisTime] = true;
				}
				
				if (typeof dataDestination[thisTime] === 'undefined')
				{				
					dataDestination[thisTime] = [];
				}

				dataDestination = dataDestination[thisTime];
			}
		}

		dataDestination.push(lineValues);	
	}
	
}

private function loadPointValues(linesArray: Array, headerLine: String, columnSeperator: String): void
{	
	_foundTimes = {};
	_tabInfo = {};
	_tabNames = [];
		
	_valueData = [];
	
	for(var i : int = 1; i < linesArray.length; i++ )
	{
		var lineString: String = linesArray[i];
		var lineValues: Array = decodeCSVRow(lineString, columnSeperator);
		
		var thisLatitude: Number = (Number)(lineValues[_latitudeColumnIndex]);
		var thisLongitude: Number = (Number)(lineValues[_longitudeColumnIndex]);

		if (isNaN(thisLatitude)||isNaN(thisLongitude))
			continue;
		
		lineValues[_latitudeColumnIndex] = thisLatitude;
		lineValues[_longitudeColumnIndex] = thisLongitude;

		if (_valueColumnIndex!==-1)
		{
			var thisValue: Number = (Number)(lineValues[_valueColumnIndex]);
			lineValues[_valueColumnIndex] = thisValue;
			
			if ((i===1)||(thisValue<_smallestValue))
				_smallestValue = thisValue;
			
			if ((i===1)||(thisValue>_largestValue))
				_largestValue = thisValue;
		}
		
		var dataDestination: Array = _valueData;
		
		if (_hasTabs)
		{
			var thisTab: String = lineValues[_tabColumnIndex];
			if (thisTab !== null)
			{
				if (typeof _tabInfo[thisTab] === 'undefined')
				{
					_tabInfo[thisTab] = {};
					_tabNames.push(thisTab);
				}
				if (typeof dataDestination[thisTab] === 'undefined')
				{
					dataDestination[thisTab] = [];
				}
				
				dataDestination = dataDestination[thisTab];
			}			
		}		
		
		if (_hasTime)
		{
			var thisTime: String = lineValues[_timeColumnIndex];
			if ((thisTime !== null)&&(thisTime!=''))
			{
				if (typeof _foundTimes[thisTime] === 'undefined')
				{
					_foundTimes[thisTime] = true;
				}
				if (typeof dataDestination[thisTime] === 'undefined')
				{
					dataDestination[thisTime] = [];
				}
				
				dataDestination = dataDestination[thisTime];
			}
		}
		
		dataDestination.push(lineValues);	
	}		
}

private function getColorForValue(thisValue: Number, minValue: Number, maxValue: Number, valueScale: Number): uint
{	
	var normalizedValue: Number = ((thisValue-minValue)*valueScale); 
	normalizedValue = Math.min(normalizedValue, 1.0);
	normalizedValue = Math.max(normalizedValue, 0.0);
	
	var fractionalIndex: Number = (normalizedValue*(_colorGradient.length-1));
	
	var lowerIndex: int = Math.floor(fractionalIndex);
	var higherIndex: int = Math.ceil(fractionalIndex);
	var lerpValue: Number = (fractionalIndex-lowerIndex);
	var oneMinusLerp: Number = (1.0-lerpValue);
	
	var lowerValue: Object = _colorGradient[lowerIndex];
	var higherValue: Object = _colorGradient[higherIndex];
	
	var alpha: int = (int)((lowerValue.alpha*oneMinusLerp)+(higherValue.alpha*lerpValue));
	var red: int = (int)((lowerValue.red*oneMinusLerp)+(higherValue.red*lerpValue));
	var green: int = (int)((lowerValue.green*oneMinusLerp)+(higherValue.green*lerpValue));
	var blue: int = (int)((lowerValue.blue*oneMinusLerp)+(higherValue.blue*lerpValue));
	
	var setColor: uint = ((alpha<<24)|(red<<16)|(green<<8)|(blue<<0));
	
	return setColor;
}

private function getValuePointsNearLatLon(lat: Number, lon: Number, radius: Number = 0): Object
{
	if (radius===0)
	{
		if (_settings.is_point_blob_radius_in_pixels)
		{
			var pixelsPerDegreeLatitude: Number = getPixelsPerDegreeLatitude();
			radius = (_settings.point_blob_radius/pixelsPerDegreeLatitude);
		}
		else
		{
			radius = _settings.point_blob_radius;
		}
	}
		
	var radiusSquared: Number = (radius*radius);

	var currentValues: Array = getCurrentValues();
		
	var result: Array = [];
	for each (var values: Array in currentValues)
	{
		var valueLat: Number = values[_latitudeColumnIndex];
		var valueLon: Number = values[_longitudeColumnIndex];
		
		var deltaLat: Number = (valueLat-lat);
		var deltaLon: Number = (valueLon-lon);
		
		var distanceSquared: Number = ((deltaLat*deltaLat)+(deltaLon*deltaLon));
		
		if (distanceSquared<radiusSquared)
		{
			var output: Object = {};
			for(var headerIndex:int = 0; headerIndex < _valueHeaders.length; headerIndex++ )
			{
				var header: String = '"'+_valueHeaders[headerIndex].toLowerCase()+'"';

				output[header] = values[headerIndex];
			}
			
			result.push(output);
		}
	
	}
	
	return result;
}

private function setSetting(key: String, value: *): void
{
	if (!_settings.hasOwnProperty(key))
	{
		logError('Unknown key in setSetting('+key+')');
		return;
	}

	if (typeof _settings[key] === "boolean")
	{	
		if (typeof value === 'string')
		{
			value = (value==='true');
		}
			
		_settings[key] = (Boolean)(value);
	}
	else
	{
		_settings[key] = value;
	}
		
	var changeHandlers: Object =
	{
		'title_text': function(): void {
			_title.htmlText = '<p align="center"><u>'+_settings.title_text+'</u></p>';
			if (_settings.title_text!=='')
				_title.y = 0;
			else
				_title.y = -1000;
		},
		'time_range_start': function(): void {
			calculateFrameTimes();
			updateTimelineDisplay();
		},
		'time_range_end': function(): void {
			calculateFrameTimes();
			updateTimelineDisplay();
		},
        'point_blob_radius': function(): void {
            _valuesDirty = true;
            _dirty = true;
        },
        'point_blob_value': function(): void {
            _valuesDirty = true;
            _dirty = true;
        },
        'gradient_value_min': function(): void {
        	_settings.is_gradient_value_range_set =
        		((_settings.gradient_value_min!=0)||
        		(_settings.gradient_value_max!=0));
            _valuesDirty = true;
            _dirty = true;
        },
        'gradient_value_max': function(): void {
        	_settings.is_gradient_value_range_set =
        		((_settings.gradient_value_min!=0)||
        		(_settings.gradient_value_max!=0));
            _valuesDirty = true;
            _dirty = true;
        },
        'ocean_color': function(): void {
        	if (typeof _settings.ocean_color === 'string')
        	{
        		_settings.ocean_color = _settings.ocean_color.replace('#', '0x');
        		_settings.ocean_color = (Number)(_settings.ocean_color);
        	}
        },
        'title_background_color': function(): void {
        	if (typeof _settings.title_background_color === 'string')
        	{
        		_settings.title_background_color = _settings.title_background_color.replace('#', '0x');
        		_settings.title_background_color = (Number)(_settings.title_background_color);
        	}
			_title.backgroundColor = _settings.title_background_color;
        },
        'show_map_tiles': function(): void {
        	if (typeof _settings.show_map_tiles==='string')
        		_settings.show_map_tiles = (Boolean)(_settings.show_map_tiles);
            _mapTilesDirty = true;
        },
        'information_alpha': function(): void {
        	setWayDefault('alpha', _settings.information_alpha);
        },
		'credit_text': function(): void {
			if (_credit !== null)
			{
				// Workaround hack for a bad default setting
				if (_settings.credit_text!='Created with <a href="http://openheatmap.com"><u>OpenHeatMap</u></a>')
				{
					_credit.htmlText = _settings.credit_text;
				}
			}
		}
   	}
	
	if (changeHandlers.hasOwnProperty(key))
		changeHandlers[key]();
}

private function repositionMoveableElements(): void
{
	if (_credit !== null)
	{
		_credit.x = (_settings.width-120);
		_credit.y = (_settings.height-20);
	}
		
	if (_title !== null)
	{
		_title.width = _settings.width;
		_title.x = 0;
	}

	if (_timelineControls !== null)
	{
		var verticalCenter: Number = ((_settings.height/2)-40);
		_timelineControls.y = (_settings.height-50);
	}

}

private function getLatLonViewingArea(): Object
{
	var topLeftScreen: Point = new Point(0, 0);
	var bottomRightScreen: Point = new Point(_settings.width, _settings.height);
		
	var topLeftLatLon: Object = getLatLonFromXY(topLeftScreen, _xYToLatLonMatrix);
	var bottomRightLatLon: Object = getLatLonFromXY(bottomRightScreen, _xYToLatLonMatrix);

	var result: Object = {
		topLat: topLeftLatLon.lat,
		leftLon: topLeftLatLon.lon,
		bottomLat: bottomRightLatLon.lat,
		rightLon: bottomRightLatLon.lon
	};
	
	return result;
}

private function removeAllInlays(): void
{
	_inlays	= [];
	
	_dirty = true;
}

private function removeAllWays(): void
{
	_ways = {};
	_nodes = {};

  	_tagMap = {};
	_lastSetWayIds = {};
	
	_wayLayers = [];
	
	_dirty = true;
}

private function getAllInlays(): Array
{
	var result: Array = [];
	
	for each(var inlay: Object in _inlays)
	{
		var topLeftScreen: Point = getXYFromLatLon(inlay.worldTopLeftLatLon, _latLonToXYMatrix);
		var bottomRightScreen: Point = getXYFromLatLon(inlay.worldBottomRightLatLon, _latLonToXYMatrix);
		
		var outputInlay: Object =
		{
			left_x: topLeftScreen.x,
			top_y: topLeftScreen.y,
			right_x: bottomRightScreen.x,
			bottom_y: bottomRightScreen.y,
			top_lat: inlay.topLat,
			left_lon: inlay.leftLon,
			bottom_lat: inlay.bottomLat,
			right_lon: inlay.rightLon
		};

		result.push(outputInlay);
	}
	
	return result;
}

private function addPopup(lat: Number, lon: Number, text: String): void
{
	var popup: Object =
	{
		originLatLon: { lat: lat, lon: lon },
		text: text
	};

	popup.uiComponent = new TextArea();
	popup.uiComponent.htmlText = text;

	popup.uiComponent.wordWrap = false;
	popup.uiComponent.horizontalScrollPolicy = "ScrollPolicy.OFF";
	popup.uiComponent.verticalScrollPolicy = "ScrollPolicy.OFF";
	
	var dropShadowFilter: DropShadowFilter = new DropShadowFilter (5,65,0x000000,0.3,5,10,2,3,false,false,false);
	popup.uiComponent.filters = [dropShadowFilter];

//	viewer.addChild(popup.uiComponent);
	
	var screenPos: Point = getXYFromLatLon(popup.originLatLon, _latLonToXYMatrix);
	
//	popup.uiComponent.validateNow();
//	
//	popup.uiComponent.width = (popup.uiComponent.textWidth+10);
//	popup.uiComponent.height = (popup.uiComponent.textHeight+20);
//	popup.uiComponent.x = (screenPos.x-popup.uiComponent.width);
//	popup.uiComponent.y = (screenPos.y-popup.uiComponent.height);
//
//	if (popup.uiComponent.x<0)
//	{
//		popup.uiComponent.x = 0;
//		popup.uiComponent.wordWrap = true;
//		popup.uiComponent.width = screenPos.x;
//		popup.uiComponent.validateNow();
//		popup.uiComponent.height = (popup.uiComponent.textHeight+5);
//	}
//	
//	if (popup.uiComponent.y<0)
//	{
//		popup.uiComponent.y = 0;
//	}
//
//	if ((popup.uiComponent.y+popup.uiComponent.height)>_settings.height)
//	{
//		popup.uiComponent.y = (_settings.height-popup.uiComponent.height);		
//	}

	_popups.push(popup);
}

private function removeAllPopups(): void
{
	for each (var popup: Object in _popups)
	{
//		viewer.removeChild(popup.uiComponent);	
	}
	
	_popups = [];
}

private function createURLForTile(latIndex: Number, lonIndex: Number, zoomIndex: Number): String
{
	var zoomTileCount: Number = (1<<zoomIndex);
	
	var trueLonIndex: Number;
	if (lonIndex<0)
		trueLonIndex = (zoomTileCount-((-lonIndex)%zoomTileCount));
	else if (lonIndex>=zoomTileCount)
		trueLonIndex = (lonIndex%zoomTileCount);
	else
		trueLonIndex = lonIndex;
	
	var result: String = _settings.map_server_root;
	result += zoomIndex;
	result += '/';
	result += trueLonIndex;
	result += '/';
	result += latIndex;
	result += '.png';
	result += '#';
	result += lonIndex;

	return result;	
}

private function drawMapTiles(graphics: Graphics, width: Number, height: Number, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): void
{
	var viewingArea: Rectangle = calculateViewingArea(width, height, xYToLatLonMatrix);
	
	var wantedTiles: Array = prepareMapTiles(viewingArea, latLonToXYMatrix, xYToLatLonMatrix, width, height);

	var areAllLoaded: Boolean = true;

	for each (var currentURL: String in wantedTiles)
	{
		if (!_mapTiles[currentURL].imageLoader._isLoaded)
			areAllLoaded = false;
	}

	var mapTilesURLs: Array = [];
	if (areAllLoaded)
	{
		mapTilesURLs = wantedTiles;
	}
	else
	{
		for (currentURL in _mapTiles)
			mapTilesURLs.push(currentURL);
	}

	for each (currentURL in mapTilesURLs)
	{
		var tile: Object = _mapTiles[currentURL];

		if (!viewingArea.intersects(tile.boundingBox))
			continue;

		if (!tile.imageLoader._isLoaded)
			continue;
		
		var screenTopLeft: Point = getXYFromLatLon(tile.topLeftLatLon, latLonToXYMatrix);
		var screenBottomRight: Point = getXYFromLatLon(tile.bottomRightLatLon, latLonToXYMatrix);
		
		var screenLeft: Number = screenTopLeft.x;
		var screenTop: Number = screenTopLeft.y;
	
		var screenWidth: Number = (screenBottomRight.x-screenTopLeft.x);
		var screenHeight: Number = (screenBottomRight.y-screenTopLeft.y);
	
		var bitmapTransform: Matrix = new Matrix();
		bitmapTransform.scale((screenWidth/_settings.map_tile_width), (screenHeight/_settings.map_tile_height));
		bitmapTransform.translate(screenLeft, screenTop);
	
		graphics.beginBitmapFill(tile.imageLoader._bitmapData, bitmapTransform, false, true);
		graphics.drawRect(screenLeft, screenTop, screenWidth, screenHeight);
		graphics.endFill();
	}
}

private function getTileIndicesFromLatLon(lat: Number, lon: Number, zoomLevel: int): Object
{
	var mercatorLatitudeOrigin: Number = latitudeToMercatorLatitude(_settings.map_tile_origin_lat);
	var mercatorLatitudeHeight: Number = latitudeToMercatorLatitude(_settings.world_lat_height+_settings.map_tile_origin_lat)-mercatorLatitudeOrigin;
	
	var zoomTileCount: Number = (1<<zoomLevel);
	var zoomPixelsPerDegreeLatitude: Number = ((_settings.map_tile_height/mercatorLatitudeHeight)*zoomTileCount);
	var zoomPixelsPerDegreeLongitude: Number = ((_settings.map_tile_width/_settings.world_lon_width)*zoomTileCount);

	var tileWidthInDegrees: Number = (_settings.map_tile_width/zoomPixelsPerDegreeLongitude);
	var tileHeightInDegrees: Number = (_settings.map_tile_height/zoomPixelsPerDegreeLatitude);

	var latIndex: Number = ((latitudeToMercatorLatitude(lat)-mercatorLatitudeOrigin)/tileHeightInDegrees);
	var lonIndex: Number = ((lon-_settings.map_tile_origin_lon)/tileWidthInDegrees);
	
	var result: Object = {
		latIndex: latIndex,
		lonIndex: lonIndex
	};
	
	return result;
}

private function getLatLonFromTileIndices(latIndex: Number, lonIndex: Number, zoomLevel: int): Object
{
	var mercatorLatitudeOrigin: Number = latitudeToMercatorLatitude(_settings.map_tile_origin_lat);
	var mercatorLatitudeHeight: Number = latitudeToMercatorLatitude(_settings.world_lat_height+_settings.map_tile_origin_lat)-mercatorLatitudeOrigin;
 	
	var zoomTileCount: Number = (1<<zoomLevel);
	var zoomPixelsPerDegreeLatitude: Number = ((_settings.map_tile_height/mercatorLatitudeHeight)*zoomTileCount);
	var zoomPixelsPerDegreeLongitude: Number = ((_settings.map_tile_width/_settings.world_lon_width)*zoomTileCount);

	var tileWidthInDegrees: Number = (_settings.map_tile_width/zoomPixelsPerDegreeLongitude);
	var tileHeightInDegrees: Number = (_settings.map_tile_height/zoomPixelsPerDegreeLatitude);

	var lat: Number = ((latIndex*tileHeightInDegrees)+mercatorLatitudeOrigin);
	var lon: Number = ((lonIndex*tileWidthInDegrees)+_settings.map_tile_origin_lon);
	
	var result: Object = {
		lat: mercatorLatitudeToLatitude(lat),
		lon: lon
	};
	
	return result;
}

private function prepareMapTiles(viewingArea: Rectangle, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix, width: Number, height: Number): Array
{	
	var pixelsPerDegreeLatitude: Number = latLonToXYMatrix.d;
	
	var zoomPixelsPerDegreeLatitude: Number = (_settings.map_tile_height/_settings.world_lat_height);
	var zoomLevel: int = 0;
	while (Math.abs(zoomPixelsPerDegreeLatitude*_settings.map_tile_match_factor)<Math.abs(pixelsPerDegreeLatitude))
	{
		zoomLevel += 1;
		zoomPixelsPerDegreeLatitude *= 2;	
	}

	var zoomTileCount: Number = (1<<zoomLevel);
	var zoomPixelsPerDegreeLongitude: Number = ((_settings.map_tile_width/_settings.world_lon_width)*zoomTileCount);
	
	var tileWidthInDegrees: Number = (_settings.map_tile_width/zoomPixelsPerDegreeLongitude);
	var tileHeightInDegrees: Number = (_settings.map_tile_height/zoomPixelsPerDegreeLatitude);

	var start: Object = getTileIndicesFromLatLon(viewingArea.bottom, viewingArea.left, zoomLevel);
	start.latIndex = Math.floor(start.latIndex);
	start.lonIndex = Math.floor(start.lonIndex);

	var end: Object = getTileIndicesFromLatLon(viewingArea.top, viewingArea.right, zoomLevel);
	end.latIndex = Math.ceil(end.latIndex);
	end.lonIndex = Math.ceil(end.lonIndex);

	var wantedTiles: Array = [];

	for (var latIndex: int = start.latIndex; latIndex<=end.latIndex; latIndex+=1)
	{
		for (var lonIndex: int = start.lonIndex; lonIndex<=end.lonIndex; lonIndex+=1)
		{
			var wantedTile: Object = {};
		
			wantedTile.latIndex = latIndex;
			wantedTile.lonIndex = lonIndex;
			wantedTile.zoomIndex = zoomLevel;
			
			wantedTile.topLeftLatLon = getLatLonFromTileIndices(latIndex, lonIndex, zoomLevel);
			wantedTile.bottomRightLatLon = getLatLonFromTileIndices((latIndex+1), (lonIndex+1), zoomLevel);

			wantedTile.boundingBox = new Rectangle();			
			wantedTile.boundingBox = enlargeBoxToContain(wantedTile.boundingBox, new Point(wantedTile.topLeftLatLon.lon, wantedTile.topLeftLatLon.lat));
			wantedTile.boundingBox = enlargeBoxToContain(wantedTile.boundingBox, new Point(wantedTile.bottomRightLatLon.lon, wantedTile.bottomRightLatLon.lat));	
		
			wantedTiles.push(wantedTile);
		}
	}
	
	var result: Array = [];
	
	for each (wantedTile in wantedTiles)
	{
		var wantedURL: String = createURLForTile(wantedTile.latIndex, wantedTile.lonIndex, wantedTile.zoomIndex);
		
		if (!_mapTiles.hasOwnProperty(wantedURL))
		{
			_mapTiles[wantedURL] = {};
			
			_mapTiles[wantedURL].imageLoader = new ExternalImageView(wantedURL, _settings.map_tile_width, _settings.map_tile_height, this);
			
			_mapTiles[wantedURL].topLeftLatLon = wantedTile.topLeftLatLon;
			_mapTiles[wantedURL].bottomRightLatLon = wantedTile.bottomRightLatLon;
			_mapTiles[wantedURL].boundingBox = wantedTile.boundingBox;
		}
		
		_mapTiles[wantedURL].isUsedThisFrame = true;
		
		result.push(wantedURL);
	}
	
	return result;
}

private function onMapTileComplete(event:Event):void
{
	var image:Image = Image(event.target);
	var sourceURL: String = image.source as String;

	_mapTiles[sourceURL].image.addEventListener(FlexEvent.UPDATE_COMPLETE, onMapTileLoaded);
}

private function onMapTileLoaded(event:Event):void
{
	var image:Image = Image(event.target);

	var sourceURL: String = image.source as String;
 
	if(image.width<=0)
		return;

	if (!_mapTiles.hasOwnProperty(sourceURL))
		return;

	var bitmapData:BitmapData = new BitmapData(image.width,image.height);
    var matrix:Matrix = new Matrix();
    bitmapData.draw(image,matrix);
    
    _mapTiles[sourceURL].bitmapData = bitmapData;
    _mapTiles[sourceURL].isLoaded = true;
    
    _dirty = true;
}

private function mercatorLatitudeToLatitude(mercatorLatitude: Number): Number
{
	var result: Number = (180/Math.PI) * (2 * Math.atan(Math.exp((mercatorLatitude*2)*Math.PI/180)) - Math.PI/2);
	
	return result;
}

private function latitudeToMercatorLatitude(latitude: Number): Number
{ 
	var result: Number = (180/Math.PI) * Math.log(Math.tan(Math.PI/4+latitude*(Math.PI/180)/2));
	
	return (result/2);
}

private function calculateViewingArea(width: Number, height: Number, xYToLatLonMatrix: Matrix): Rectangle
{
	var viewingArea: Rectangle = new Rectangle();
	
	var topLeftScreen: Point = new Point(0, 0);
	var bottomRightScreen: Point = new Point(width, height);
		
	var topLeftLatLon: Object = getLatLonFromXY(topLeftScreen, xYToLatLonMatrix);
	var bottomRightLatLon: Object = getLatLonFromXY(bottomRightScreen, xYToLatLonMatrix);
	
	viewingArea = enlargeBoxToContain(viewingArea, new Point(topLeftLatLon.lon, topLeftLatLon.lat));
	viewingArea = enlargeBoxToContain(viewingArea, new Point(bottomRightLatLon.lon, bottomRightLatLon.lat));	

	return viewingArea;	
}

private function trackMapTilesUsage(): void
{
	for (var currentURL: String in _mapTiles)
	{
		_mapTiles[currentURL].isUsedThisFrame = false;	
	}	
}

private function deleteUnusedMapTiles(): void
{
	var areAllLoaded: Boolean = true;

	for (var currentURL: String in _mapTiles)
	{
		if (_mapTiles[currentURL].isUsedThisFrame&&
			!_mapTiles[currentURL].imageLoader._isLoaded)
			areAllLoaded = false;
	}

	_mapTilesDirty = false;
	
	if (areAllLoaded)
	{
		for (currentURL in _mapTiles)
		{
			if (!_mapTiles[currentURL].isUsedThisFrame)
			{
				_mapTiles[currentURL].imageLoader = null;
				delete _mapTiles[currentURL];
				_mapTilesDirty = true;
			}	
		}
	}			
}

private function getValueHeaders(): Array
{
	return _valueHeaders;	
}

private function addPopupAtScreenPosition(x: Number, y: Number, text: String): void
{
	var latLon: Object = getLatLonFromXY(new Point(x, y), _xYToLatLonMatrix);
	
	addPopup(latLon.lat, latLon.lon, text);	
}

private function getCurrentValues(): Array
{
	var currentValues: Array = _valueData;	

	if (_hasTabs)
	{
		var currentTab: String = _tabNames[_selectedTabIndex];
		currentValues = currentValues[currentTab];
	}
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = currentValues[currentTime];
	}

	return currentValues;
}

private function drawTabsIntoViewer(): void
{
	var tabCount: int = _tabNames.length;
		
	var tabHeight: Number = _settings.tab_height;
	
	var tabTopY: Number;
	if (_settings.title_text!=='')
		tabTopY = (_settings.title_size*1.5);
	else
		tabTopY = 0;
	
	var tabBottomY: Number = (tabTopY+tabHeight);
	
	var graphics: Graphics = viewer.graphics;
	
	var tabLeftX: Number = 0;
	
	for (var tabIndex:int = 0; tabIndex<tabCount; tabIndex+=1)
	{
		var isLast: Boolean = (tabIndex==(tabCount-1));
		var isSelected: Boolean = (tabIndex===_selectedTabIndex);
		var isHovered: Boolean = (tabIndex===_hoveredTabIndex);

		var tabName: String = _tabNames[tabIndex];
		var tabInfo: Object = _tabInfo[tabName];
		
		var textfield:TextField = new TextField;
		textfield.text = tabName;
		var tabWidth: int = (textfield.textWidth+5);		
		textfield.width = tabWidth;
		
		var tabRightX: Number = (tabLeftX+tabWidth);
		var distanceFromEdge: Number = (_settings.width-tabRightX);
		var addExtraTab: Boolean = (isLast&&(distanceFromEdge>50));
		
		if (isLast&&!addExtraTab)
		{
			tabRightX = (_settings.width-1);
			tabWidth = (tabRightX-tabLeftX);
		}

		tabInfo.leftX = tabLeftX;
		tabInfo.rightX = tabRightX;
		tabInfo.topY = tabTopY;
		tabInfo.bottomY = tabBottomY;
		
		if (tabWidth<1)
			continue;
		
		var fillColor: uint;
		if (isSelected)
			fillColor = _settings.title_background_color;
		else if (isHovered)
			fillColor = scaleColorBrightness(_settings.title_background_color, 0.95);
		else
			fillColor = scaleColorBrightness(_settings.title_background_color, 0.9);
		
		graphics.lineStyle();

		graphics.beginFill(fillColor, 1.0);	
		graphics.moveTo(tabLeftX, tabTopY);
		graphics.lineTo(tabRightX, tabTopY);
		graphics.lineTo(tabRightX, tabBottomY);
		graphics.lineTo(tabLeftX, tabBottomY);
		graphics.lineTo(tabLeftX, tabTopY);
		graphics.endFill();

		var bitmapdata:BitmapData = new BitmapData(tabWidth, tabHeight, true, 0x00000000);
		bitmapdata.draw(textfield);
		
		var textMatrix: Matrix = new Matrix();
		textMatrix.translate(tabLeftX, tabTopY);
		
		graphics.beginBitmapFill(bitmapdata, textMatrix);
		graphics.drawRect(tabLeftX, tabTopY, tabWidth, tabHeight);
		graphics.endFill();

		graphics.lineStyle(0, 0x000000, 1.0);
		graphics.moveTo(tabLeftX, tabBottomY);
		graphics.lineTo(tabLeftX, tabTopY);
		graphics.lineTo(tabRightX, tabTopY);
		graphics.lineTo(tabRightX, tabBottomY);
		if (!isSelected)
			graphics.lineTo(tabLeftX, tabBottomY);

		tabLeftX = tabRightX;

		if (addExtraTab)
		{
			tabRightX = (_settings.width-1);
			
			fillColor = scaleColorBrightness(_settings.title_background_color, 0.9);
			
			graphics.beginFill(fillColor, 1.0);	
			graphics.moveTo(tabLeftX, tabTopY);
			graphics.lineTo(tabRightX, tabTopY);
			graphics.lineTo(tabRightX, tabBottomY);
			graphics.lineTo(tabLeftX, tabBottomY);
			graphics.lineTo(tabLeftX, tabTopY);
			graphics.endFill();

			graphics.lineStyle(0, 0x000000, 1.0);
			graphics.moveTo(tabLeftX, tabBottomY);
			graphics.lineTo(tabLeftX, tabTopY);
			graphics.lineTo(tabRightX, tabTopY);
			graphics.lineTo(tabRightX, tabBottomY);
		}
		
	}
	
	graphics.lineStyle(0, 0x000000, 1.0);
	graphics.moveTo(0, tabBottomY);
	graphics.lineTo(0, (_settings.height-1));
	graphics.lineTo((_settings.width-1), (_settings.height-1));
	graphics.lineTo((_settings.width-1), tabBottomY);
}

private function scaleColorBrightness(colorNumber: uint, scale: Number): uint
{
	var alpha: uint = (colorNumber>>24)&0xff;
	var red: uint = (colorNumber>>16)&0xff;
	var green: uint = (colorNumber>>8)&0xff;
	var blue: uint = (colorNumber>>0)&0xff;
	
	var resultAlpha: uint = alpha; // We'll end up with 'illegal' premult color values, but this shouldn't be a proble for our uses
	var resultRed: uint = Math.floor(red*scale);
	var resultGreen: uint = Math.floor(green*scale);
	var resultBlue: uint = Math.floor(blue*scale);
	
	resultRed = Math.max(0, resultRed);
	resultGreen = Math.max(0, resultGreen);
	resultBlue = Math.max(0, resultBlue);
		
	resultRed = Math.min(255, resultRed);
	resultGreen = Math.min(255, resultGreen);
	resultBlue = Math.min(255, resultBlue);
	
	var result: uint =
		(resultAlpha<<24)|
		(resultRed<<16)|
		(resultGreen<<8)|
		(resultBlue<<0);
	
	return result;
}

private function isEventInTopBar(event: MouseEvent): Boolean
{
	var hasTitle: Boolean = (_settings.title_text!=='');
	
	if ((!hasTitle)&&(!_hasTabs||!_settings.show_tabs))
		return false;
	
	var tabHeight: Number = _settings.tab_height;
	
	var tabTopY: Number;
	if (hasTitle)
		tabTopY = (_settings.title_size*1.5);
	else
		tabTopY = 0;
	
	var tabBottomY: Number = (tabTopY+tabHeight);
	
	return (event.localY<tabBottomY);
}

private function onTopBarClick(event: MouseEvent): Boolean
{
	var tabIndex: int = getTabIndexFromEvent(event);
	
	if (tabIndex!==-1)
	{
		_selectedTabIndex = tabIndex;
		_valuesDirty = true;
		_dirty = true;
	}
	
	return true;
}
	
private function onTopBarDoubleClick(event: MouseEvent): Boolean
{
	var tabIndex: int = getTabIndexFromEvent(event);
	
	if (tabIndex!==-1)
	{
		_selectedTabIndex = tabIndex;
		_valuesDirty = true;
		_dirty = true;
	}
	
	return true;
}
	
private function onTopBarMouseDown(event: MouseEvent): Boolean
{	
	return true;	
}

private function onTopBarMouseUp(event: MouseEvent): Boolean
{	
	return true;		
}

private function onTopBarMouseOver(event: MouseEvent): Boolean
{
	return true;	
}

private function onTopBarMouseOut(event: MouseEvent): Boolean
{
	return true;	
}
	
private function onTopBarMouseMove(event: MouseEvent): Boolean
{
	var tabIndex: int = getTabIndexFromEvent(event);
	
	_hoveredTabIndex = tabIndex;
	
	return true;	
}
	
private function getTabIndexFromEvent(event: MouseEvent): int
{
	var x: Number = event.localX;
	var y: Number = event.localY;
	
	for (var tabIndex:int = 0; tabIndex<_tabNames.length; tabIndex+=1)
	{
		var tabName: String = _tabNames[tabIndex];
		var tabInfo: Object = _tabInfo[tabName];
		
		if ((x>=tabInfo.leftX)&&
			(x<tabInfo.rightX)&&
			(y>=tabInfo.topY)&&
			(y<tabInfo.bottomY))
			return tabIndex;
	}
	
	return -1;
}
	
private function createPointsGrid(viewingArea: Rectangle, latLonToXYMatrix: Matrix): void
{
	if (!_hasPointValues)
		return;

	var blobRadius: Number;
	if (_settings.is_point_blob_radius_in_pixels)
	{	
		var pixelsPerDegreeLatitude: Number = latLonToXYMatrix.d;
		blobRadius = Math.abs(_settings.point_blob_radius/pixelsPerDegreeLatitude);
	}
	else
	{
		blobRadius = _settings.point_blob_radius;	
	}
	var twoBlobRadius: Number = (2*blobRadius);
	var pointBlobValue: Number = _settings.point_blob_value;

	_pointsGrid = new BucketGrid(viewingArea, 64, 64);
	
	var currentValues: Array = getCurrentValues();
	
	var hasValues: Boolean = (_valueColumnIndex!==-1);
	
	var index: int = 0;
	for each (var values: Array in currentValues)
	{
		var lat: Number = values[_latitudeColumnIndex];
		var lon: Number = values[_longitudeColumnIndex];
		var pointValue: Number;
		if (hasValues)
			pointValue = values[_valueColumnIndex];
		else
			pointValue = pointBlobValue;
		
		var boundingBox: Rectangle = new Rectangle(lon-blobRadius, lat-blobRadius, twoBlobRadius, twoBlobRadius);
		
		if (!viewingArea.intersects(boundingBox))
			continue;
		
		var latLon: Object = { 
			pos: new Point(lon, lat),
			index: index,
			value: pointValue
		};
		
		_pointsGrid.insertObjectAt(boundingBox, latLon);
		
		index += 1;
	}		
}

public function drawPointBlobTile(width: Number, 
	height: Number, 
	viewingArea: Rectangle, 
	latLonToXYMatrix: Matrix, 
	xYToLatLonMatrix: Matrix, 
	leftX: int,
	topY: int,
	tileWidth: int, 
	tileHeight: int): void
{
	var bitmapWidth: int = _pointBlobBitmapWidth;
	var bitmapHeight: int = _pointBlobBitmapHeight;
	
	var rightX: int = (leftX+tileWidth);
	var bottomY: int = (topY+tileHeight);
	
	var blobRadius: Number;
	var pixelsPerDegreeLatitude: Number = latLonToXYMatrix.d;
	if (_settings.is_point_blob_radius_in_pixels)
	{	
		blobRadius = Math.abs(_settings.point_blob_radius/pixelsPerDegreeLatitude);
	}
	else
	{
		blobRadius = _settings.point_blob_radius;	
	}
	var twoBlobRadius: Number = (2*blobRadius);
	var blobRadiusSquared: Number = (blobRadius*blobRadius);
	var blobRadiusInPixels: Number = Math.abs(blobRadius*pixelsPerDegreeLatitude)/2.0;
	
	if (_settings.is_gradient_value_range_set)
	{
		var minValue: Number = _settings.gradient_value_min;
		var maxValue: Number = _settings.gradient_value_max;	
		if (Math.abs(maxValue-minValue)<0.00001)	
			minValue = (maxValue-1.0);
	}
	else
	{
		minValue = 0;
		maxValue = 1.0;
	}
	var valueScale: Number = (1/(maxValue-minValue));
	
	var hasValues: Boolean = (_valueColumnIndex!==-1);
	
	var isValueDistance: Boolean = (_settings.is_value_distance);
		
	var leftLon: Number = viewingArea.left;
	var rightLon: Number = viewingArea.right;
	var widthLon: Number = (rightLon-leftLon);
	var stepLon: Number = (widthLon/bitmapWidth);
	
	var topLat: Number = viewingArea.bottom;
	var bottomLat: Number = viewingArea.top;
	
	var topLatMercator: Number = latitudeToMercatorLatitude(topLat);
	var bottomLatMercator: Number = latitudeToMercatorLatitude(bottomLat);
	var heightLat: Number = (bottomLatMercator-topLatMercator);
	var stepLat: Number = (heightLat/bitmapHeight);
	
	var pixelData: ByteArray = new ByteArray();
	
	var zeroColor: uint = 0x00000000;
	var fullColor: uint = getColorForValue(maxValue, minValue, maxValue, valueScale);
	
	var worldPoint: Point = new Point();
	for (var bitmapY: int = topY; bitmapY<bottomY; bitmapY+=1)
	{
		worldPoint.y = mercatorLatitudeToLatitude(topLatMercator+(stepLat*bitmapY));
		for (var bitmapX: int = leftX; bitmapX<rightX; bitmapX+=1)
		{			
			worldPoint.x = (leftLon+(stepLon*bitmapX));
			
			var candidatePoints: Array = _pointsGrid.getContentsAtPoint(worldPoint);
			
			if (candidatePoints.length<1)
			{
				pixelData.writeUnsignedInt(zeroColor);
				continue;
			}
			
			var value: Number = 0;
			var lerpTotal: Number = 0;
			var minDistance: Number = blobRadius;
			
			for each (var point: Object in candidatePoints)
			{
				var pos: Point = point.pos;
				var delta: Point = worldPoint.subtract(pos);
				var distanceSquared: Number = ((delta.x*delta.x)+(delta.y*delta.y));
				if (distanceSquared>blobRadiusSquared)
					continue;
				
				var distance: Number = Math.sqrt(distanceSquared);
				var lerp: Number = (1-(distance/blobRadius));
				
				value += (point.value*lerp);
				lerpTotal += lerp;
				minDistance = Math.min(minDistance, distance);
			}
			
			if (isValueDistance)
			{
				value = (minValue+((1-(minDistance/blobRadius))*valueScale));				
			}
			else if (lerpTotal>0)
			{
				if (hasValues)
				{
					value = (value/lerpTotal);
				}
			}
			else
			{
				value = 0;
			}
			
			var alpha: uint = Math.floor(255*(Math.min(lerpTotal, 1.0)));
			
			var color: uint = getColorForValue(value, minValue, maxValue, valueScale);
			
			var colorAlpha: uint = (color>>24)&0xff;
			var outputAlpha: uint = ((colorAlpha*alpha)>>8)&0xff;
			
			color = (color&0x00ffffff)|(outputAlpha<<24);
			
			pixelData.writeUnsignedInt(color);
		}	
	}
	
	pixelData.position = 0;
	
	_pointBlobBitmap.setPixels(new Rectangle(leftX, topY, tileWidth, tileHeight), pixelData);
}

private function setAnimationTime(time: String): void
{
	for (var index: String in _frameTimes)
	{
		if (_frameTimes[index] === time)
		{
			_frameIndex = (Number)(index);
			updateTimelineDisplay();
			break;
		}
		
	}	
}
	
private function drawPopupsIntoViewer(): void
{
	var graphics: Graphics = viewer.graphics;

	for each (var popup: Object in _popups)
	{
		var screenPos: Point = getXYFromLatLon(popup.originLatLon, _latLonToXYMatrix);
		
		var newFormat:TextFormat = new TextFormat();
		newFormat.font = 'Baskerville';
		newFormat.size = 16;
		
		var popupLineHeight: int = 22;
		
		var popupLeftX: Number = Math.max(0, (screenPos.x-popupWidth));
		var popupRightX: Number = (popupLeftX+popupWidth);
				
		var fillColor: uint = 0xffffff;

		var popupLines: Array = popup.text.split('&lt;br/&gt;');

		var maxPopupWidth: Number = 0;
		
		for (var lineIndex: String in popupLines)
		{
			var line: String = popupLines[lineIndex];
			var textfield:TextField = new TextField;
			textfield.text = line;
			textfield.setTextFormat(newFormat);
			var currentPopupWidth: int = (textfield.textWidth+5);
			maxPopupWidth = Math.max(maxPopupWidth, currentPopupWidth);
		}
		
		var linesCount: int = popupLines.length;
		
		var boxTopY: Number = (screenPos.y-popupLineHeight);
		var boxBottomY: Number = (boxTopY+(linesCount*popupLineHeight));
		var boxLeftX: Number = popupLeftX;
		var boxRightX: Number = (boxLeftX+maxPopupWidth);
		
		graphics.lineStyle();
		
		graphics.beginFill(fillColor, 1.0);	
		graphics.moveTo(boxLeftX, boxTopY);
		graphics.lineTo(boxRightX, boxTopY);
		graphics.lineTo(boxRightX, boxBottomY);
		graphics.lineTo(boxLeftX, boxBottomY);
		graphics.lineTo(boxLeftX, boxTopY);
		graphics.endFill();
		
		for (lineIndex in popupLines)
		{
			var popupTopY: Number = Math.max(0, (screenPos.y-popupLineHeight)+(popupLineHeight*(int)(lineIndex)));
			var popupBottomY: Number = (popupTopY+popupLineHeight);

			line = popupLines[lineIndex];
			textfield = new TextField;
			textfield.text = line;
			textfield.setTextFormat(newFormat);
			var popupWidth: int = (textfield.textWidth+5);
			textfield.width = popupWidth;
						
			var bitmapdata:BitmapData = new BitmapData(popupWidth, popupLineHeight, true, 0x00000000);
			bitmapdata.draw(textfield);
			
			var textMatrix: Matrix = new Matrix();
			textMatrix.translate(popupLeftX, popupTopY);
			
			graphics.beginBitmapFill(bitmapdata, textMatrix);
			graphics.drawRect(popupLeftX, popupTopY, popupWidth, popupLineHeight);
			graphics.endFill();			
		}
		
		graphics.lineStyle(0, 0x000000, 1.0);
		graphics.moveTo(boxLeftX, boxTopY);
		graphics.lineTo(boxRightX, boxTopY);
		graphics.lineTo(boxRightX, boxBottomY);
		graphics.lineTo(boxLeftX, boxBottomY);
		graphics.lineTo(boxLeftX, boxTopY);
	}
}

private function getAnimationTime(): String
{
	if (!_hasTime)
		return null;
	
	var currentTime: String = _frameTimes[_frameIndex];
	return currentTime;	
}
	
private function getTabInfo(): Object
{
	if (!_hasTabs)
		return null;
	
	var result: Object = {
		'selected_tab_index': _selectedTabIndex,
		'tab_names': _tabNames
	};
	
	return result;
}
	
private function selectTab(tabIndex: Number): void
{
	_selectedTabIndex = tabIndex;
	_valuesDirty = true;
	_dirty = true;
}

// See http://www.twisty.com/bandwagon/archives/2007/07/23/162642
private function trim(str:String):String
{
	for(var i: int = 0; str.charCodeAt(i) < 33; i++) {}
	for(var j: int = str.length-1; str.charCodeAt(j) < 33; j--) {}
	return str.substring(i, j+1);
}
	
private function createZoomSlider(): void
{
	_zoomSlider = new VSlider();
	_zoomSlider.x = 4;
	_zoomSlider.y = 50;
	_zoomSlider.height = 150;
	_zoomSlider.showDataTip = false;
	_zoomSlider.minimum = 0;
	_zoomSlider.maximum = 1;
	_zoomSlider.liveDragging = true;
	_zoomSlider.setStyle("thumbSkin", VThumbImage);
	_zoomSlider.setStyle("trackSkin", VTrackImage);
	
	_zoomSlider.addEventListener( SliderEvent.CHANGE, onZoomThumbDrag );
	_zoomSlider.addEventListener( SliderEvent.THUMB_DRAG, onZoomThumbDrag );
	_zoomSlider.addEventListener( SliderEvent.THUMB_RELEASE, onZoomThumbRelease );
	_zoomSlider.addEventListener( SliderEvent.THUMB_PRESS, onZoomThumbRelease );
	
	addChild(_zoomSlider);
	
	_plusImage = BitmapAsset( new PlusImage() );
	_minusImage = BitmapAsset( new MinusImage() );
	
	var blackTint:ColorTransform = new ColorTransform();
	blackTint.color = 0x000000;
	
	_plusImage.x = 8;
	_plusImage.y = 37;
	_plusImage.transform.colorTransform = blackTint;
	viewer.addChild(_plusImage);
	
	_minusImage.x = 8;
	_minusImage.y = 195;
	_minusImage.transform.colorTransform = blackTint;
	viewer.addChild(_minusImage);
	
	updateZoomSliderDisplay();
}
	
private function destroyZoomSlider(): void
{
	if (_zoomSlider === null)
		return;
	
	removeChild(_zoomSlider);
	viewer.removeChild(_plusImage);
	viewer.removeChild(_minusImage);
}

private function drawBackgroundBitmap(width: Number, height: Number, viewingArea: Rectangle, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): BitmapData
{
	if (!_hasPointValues)
		return null;
	
	if ((_redrawCountdown>0)&&(!_dirty))
		return null;

	var result: BitmapData = null;
	
	var pointDrawingShape: String = _settings.point_drawing_shape;
	if ((pointDrawingShape=='blob')||(_settings.is_value_distance))
		result = drawPointBlobBitmap(width, height, viewingArea, latLonToXYMatrix, xYToLatLonMatrix);
	else if (pointDrawingShape=='circle')
		result = drawPointCircleBitmap(width, height, viewingArea, latLonToXYMatrix, xYToLatLonMatrix);
	else if (pointDrawingShape=='sprite')
		result = drawPointSpriteBitmap(width, height, viewingArea, latLonToXYMatrix, xYToLatLonMatrix);
	else
		logError('Unknown type in setting point_drawing_shape: "'+pointDrawingShape+'"');

	return result;
}

private function drawPointCircleBitmap(width: Number, height: Number, viewingArea: Rectangle, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): BitmapData
{
	var pixelsPerDegreeLatitude: Number = latLonToXYMatrix.d;
	var blobRadius: Number;
	if (_settings.is_point_blob_radius_in_pixels)
	{	
		blobRadius = Math.abs(_settings.point_blob_radius/pixelsPerDegreeLatitude);
	}
	else
	{
		blobRadius = _settings.point_blob_radius;	
	}
	var twoBlobRadius: Number = (2*blobRadius);
	var pointBlobValue: Number = _settings.point_blob_value;
	var radiusInPixels: Number = Math.abs(blobRadius*pixelsPerDegreeLatitude);
	
	if (_settings.is_gradient_value_range_set)
	{
		var minValue: Number = _settings.gradient_value_min;
		var maxValue: Number = _settings.gradient_value_max;	
	}
	else
	{
		minValue = _smallestValue;
		maxValue = _largestValue;
	}
	if (Math.abs(maxValue-minValue)<0.00001)	
		minValue = (maxValue-1.0);
	var valueScale: Number = (1/(maxValue-minValue));	
	
	var currentValues: Array = getCurrentValues();
	
	var hasValues: Boolean = (_valueColumnIndex!==-1);

	var foundPoints: Array = [];	
	for each (var values: Array in currentValues)
	{
		var lat: Number = values[_latitudeColumnIndex];
		var lon: Number = values[_longitudeColumnIndex];
		var pointValue: Number;
		if (hasValues)
			pointValue = values[_valueColumnIndex];
		else
			pointValue = pointBlobValue;
		
		var boundingBox: Rectangle = new Rectangle(lon-blobRadius, lat-blobRadius, twoBlobRadius, twoBlobRadius);
		
		if (!viewingArea.intersects(boundingBox))
			continue;
	
		foundPoints.push({
				"lat": lat,
				"lon": lon,
				"value": pointValue
		});
	}
		
	foundPoints.sort(function (a: Object, b: Object): int { return a.value-b.value; });	
	
	var shape: Shape = new Shape();
	var graphics: Graphics = shape.graphics;
	graphics.clear();	

	var lineColor: Number = Number(_settings.circle_line_color)
	var lineAlpha: Number = Number(_settings.circle_line_alpha)
	var lineThickness: Number = Number(_settings.circle_line_thickness)

	for (var index: int = 0; index<foundPoints.length; index += 1)
	{
		var point: Object = foundPoints[index];
		
		var center: Point = getXYFromLatLon(point, latLonToXYMatrix);
		pointValue = point.value;
		
		var currentColorAndAlpha: uint = getColorForValue(pointValue, minValue, maxValue, valueScale);
		var currentColor: uint = (currentColorAndAlpha & 0x00ffffff);
		var currentAlpha: Number = ((currentColorAndAlpha>>24) & 0xff)/255.0;

		var normalizedValue: Number = (((pointValue-minValue)*valueScale));
		normalizedValue = Math.max(0.0, normalizedValue);
		
		var currentRadius: Number = (Math.sqrt(normalizedValue)*radiusInPixels);
		
		currentRadius = Math.max(_settings.circle_minimum_radius, currentRadius);
		
		if (lineAlpha<0.01)
			graphics.lineStyle();
		else
			graphics.lineStyle(lineThickness, lineColor, (lineAlpha*currentAlpha));
		
		graphics.beginFill(currentColor, currentAlpha);		
		
		graphics.drawCircle(center.x, center.y, currentRadius);
	}		

	shape.filters = [new DropShadowFilter(4.0, 45, 0x000000, 0.8, 12.0, 12.0)];
	
	var result: BitmapData = new BitmapData(width, height, true, 0x000000);
	result.draw(shape, new Matrix());	

	_pointBlobStillRendering = false;
	
	return result;
}

private function drawPointSpriteBitmap(width: Number, height: Number, viewingArea: Rectangle, latLonToXYMatrix: Matrix, xYToLatLonMatrix: Matrix): BitmapData
{
	var pixelsPerDegreeLatitude: Number = latLonToXYMatrix.d;
	var blobRadius: Number = Math.abs(64/pixelsPerDegreeLatitude);
	var twoBlobRadius: Number = (2*blobRadius);
	var pointBlobValue: Number = _settings.point_blob_value;
	var radiusInPixels: Number = Math.abs(blobRadius*pixelsPerDegreeLatitude);
	
	if (_settings.is_gradient_value_range_set)
	{
		var minValue: Number = _settings.gradient_value_min;
		var maxValue: Number = _settings.gradient_value_max;	
	}
	else
	{
		minValue = _smallestValue;
		maxValue = _largestValue;
	}
	if (Math.abs(maxValue-minValue)<0.00001)	
		minValue = (maxValue-1.0);
	var valueScale: Number = (1/(maxValue-minValue));	
	
	var currentValues: Array = getCurrentValues();
	
	var hasValues: Boolean = (_valueColumnIndex!==-1);
	
	var foundPoints: Array = [];	
	for each (var values: Array in currentValues)
	{
		var lat: Number = values[_latitudeColumnIndex];
		var lon: Number = values[_longitudeColumnIndex];
		var pointValue: Number;
		if (hasValues)
			pointValue = values[_valueColumnIndex];
		else
			pointValue = pointBlobValue;
		
		var boundingBox: Rectangle = new Rectangle(lon-blobRadius, lat-blobRadius, twoBlobRadius, twoBlobRadius);
		
		if (!viewingArea.intersects(boundingBox))
			continue;
		
		foundPoints.push({
			"lat": lat,
			"lon": lon,
			"value": pointValue
		});
	}
	
	foundPoints.sort(function (a: Object, b: Object): int { return b.lat-a.lat; });	

	var defaultImage: BitmapData = getExternalImageAsBitmapData(_settings.default_pin_image);
	
	var defaultImageWidth: int = defaultImage.width;
	var defaultImageHeight: int = defaultImage.height;
	
	var defaultHalfWidth: Number = (defaultImageWidth/2.0);
	var defaultHalfHeight: Number = (defaultImageHeight/2.0);

	var shape: Shape = new Shape();
	var graphics: Graphics = shape.graphics;
	graphics.clear();	
		
	for (var index: int = 0; index<foundPoints.length; index += 1)
	{
		var point: Object = foundPoints[index];
		
		var center: Point = getXYFromLatLon(point, latLonToXYMatrix);
		pointValue = point.value;
				
		var normalizedValue: Number = (((pointValue-minValue)*valueScale));
		normalizedValue = Math.max(0.0, normalizedValue);

		var leftX: Number = (center.x-defaultHalfWidth);
		var topY: Number = (center.y-defaultHalfHeight);

		if (defaultImage == null)
			continue;
		
		var imageMatrix: Matrix = new Matrix();
		imageMatrix.translate(leftX, topY);
		
		graphics.beginBitmapFill(defaultImage, imageMatrix);
		graphics.drawRect(leftX, topY, defaultImageWidth, defaultImageHeight);
		graphics.endFill();			
	}		
	
//	shape.filters = [new DropShadowFilter(4.0, 45, 0x000000, 0.8, 12.0, 12.0)];
	
	var result: BitmapData = new BitmapData(width, height, true, 0x000000);
	result.draw(shape, new Matrix());	
	
	_pointBlobStillRendering = false;
	
	return result;
}
	
private function getExternalImageAsBitmapData(url: String): BitmapData
{
	if (typeof _externalImages[url] === 'undefined')
	{
		_externalImages[url] = {
			loader: new Loader()
		};
		_externalImages[url].loader.load(new URLRequest(url));
	}

	if (_externalImages[url].loader.content == null)
		return null;

	var bitmap: Bitmap = _externalImages[url].loader.content as Bitmap;
	
	var result: BitmapData = bitmap.bitmapData;

	return result;
}
	
]]>
</mx:Script>
<mx:UIComponent id="viewer"></mx:UIComponent>
	
</mx:Application>
