<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" 
    width="800" height="600" 
    applicationComplete="startup()">

<mx:Script>
<![CDATA[

import mx.controls.Label;
import flash.external.ExternalInterface; 
import mx.controls.Text;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import TimelineControls;

public var _drawingSurface:UIComponent = new UIComponent();
public var _dirty: Boolean = true;
public var _redrawCountdown: int = 0;
public var _oceanColor: Number = 0xd0e0ff;

public var _lineDefaults: Object = {
	color: 0x000000,
	thickness: 1.0,
	alpha: 0.5,
	highlight: false,
	highlightColor: 0xff0000,
	highlightAlpha: 1.0
};

public var _wayDefaults: Object = {
	color: 0x000000,
	alpha: 1.0,
	highlight: false,
	highlightColor: 0xff0000,
	highlightAlpha: 1.0,
	scale: 1.0
};

public var _colorGradient: Array = [
	{red: 0x00, green: 0x00, blue: 0xff},
	{red: 0xff, green: 0xff, blue: 0x00},
	{red: 0x80, green: 0x00, blue: 0x00},
	{red: 0xa0, green: 0x00, blue: 0x00},
	{red: 0xc0, green: 0x00, blue: 0x00},
	{red: 0xd0, green: 0x00, blue: 0x00},
	{red: 0xff, green: 0x00, blue: 0x00}
];

public var _highlightColor: Number = 0xff0000;

public var _onClickFunction: String = null;
public var _onDoubleClickFunction: String = null;
public var _onMouseDownFunction: String = null;
public var _onMouseUpFunction: String = null;
public var _onMouseOverFunction: String = null;
public var _onMouseOutFunction: String = null;
public var _onMouseMoveFunction: String = null;
public var _onEveryFrameFunction: String = null;

public var _lines: Array = [];
public var _caption: TextField = new TextField();
public var _centerPoint: Point = new Point(0,0);
public var _zoom: Number = 1.0;
public var _width: Number = 800;
public var _height: Number = 600;

public var _nodes: Object = {};
public var _ways: Object = {};

public var _xml_loader: URLLoader;
public var _isLoadingXML: Boolean = false;
public var _xml_file_name: String = "";

public var _values_loader: URLLoader;
public var _isLoadingValues: Boolean = false;
public var _values_file_name: String = "";

public var _valueHeaders: Array = null;
public var _valueData: Array = null;
public var _timeColumnIndex: int;
public var _valueColumnIndex: int;

public var _smallestValue: Number;
public var _largestValue: Number;

public var _hasTime: Boolean = false;
public var _frameTimes: Array = [];
public var _frameIndex: Number = 0;

public var _tagMap: Object = {};

public var _latLonToXYMatrix: Matrix = new Matrix();
public var _xYToLatLonMatrix: Matrix = new Matrix();

public var _worldBoundingBox: Rectangle = new Rectangle();
public var _bucketGridRows: int = 16;
public var _bucketGridColumns: int = 16;
public var _bucketGrid: Array = [];

public var _timelineControls: TimelineControls = null;

private function getURLInput(name: String, defaultValue: String = null): String
{
	if (mx.core.Application.application.parameters.hasOwnProperty(name))
		return mx.core.Application.application.parameters[name];
	else
		return defaultValue;
}
	
public function startup():void
{
	setSize(800, 600);
	setLatLonViewingArea(90, -180, -90, 180);
	
    viewer.addChild(_drawingSurface);
    viewer.addChild(_caption);
	    
    _drawingSurface.addEventListener( MouseEvent.CLICK, mapMouseClickHandler );
    _drawingSurface.addEventListener( MouseEvent.DOUBLE_CLICK, mapMouseDoubleClickHandler );
    _drawingSurface.addEventListener( MouseEvent.MOUSE_DOWN, mapMouseDownHandler );
    _drawingSurface.addEventListener( MouseEvent.MOUSE_MOVE, mapMouseMoveHandler );
    _drawingSurface.addEventListener( MouseEvent.MOUSE_OUT, mapMouseOutHandler );
    _drawingSurface.addEventListener( MouseEvent.MOUSE_OVER, mapMouseOverHandler );
    _drawingSurface.addEventListener( MouseEvent.MOUSE_UP, mapMouseUpHandler );
//    drawingSurface.addEventListener( MouseEvent.MOUSE_WHEEL, mapMouseWheelHandler );

	_dirty = true;

	addEventListener(Event.ENTER_FRAME, doEveryFrame);
	
	ExternalInterface.addCallback("setSize", setSize);      	
	ExternalInterface.addCallback("setLatLonViewingArea", setLatLonViewingArea);      	
	ExternalInterface.addCallback("setOceanColor", function(color: Number): void { _oceanColor = color; _dirty = true; });
	ExternalInterface.addCallback("setBorderColor", setBorderColor);
	ExternalInterface.addCallback("setLineDefault", setLineDefault);
	ExternalInterface.addCallback("setWayDefault", setLineDefault);
	ExternalInterface.addCallback('setMouseHandler', setMouseHandler);
	ExternalInterface.addCallback("setEveryFrameHandler", function(functionName: String): void { _onEveryFrameFunction = functionName; });
	ExternalInterface.addCallback('addLine', addLine);
	ExternalInterface.addCallback('removeLines', removeLines);
	ExternalInterface.addCallback('highlightLines', highlightLines);
	ExternalInterface.addCallback('unHighlightLines', unHighlightLines);
	ExternalInterface.addCallback('setCaption', setCaption);
	ExternalInterface.addCallback("loadFromXMLFile", loadFromXMLFile);      	
	ExternalInterface.addCallback("isLoadingXML", isLoadingXML);
	ExternalInterface.addCallback("loadValuesFromFile", loadValuesFromFile);
	ExternalInterface.addCallback("setColorGradient", setColorGradient);	
	ExternalInterface.addCallback("getWaysContainingLatLon", getWaysContainingLatLon);
	ExternalInterface.addCallback("getValueForWayId", getValueForWayId);

	var onLoadFunction: String = getURLInput('onload', 'onFlashReady');
	if (onLoadFunction !== null)
		ExternalInterface.call(onLoadFunction, '');
}

private function setLineDefault(propertyName: String, propertyValue: Object): void
{
	_lineDefaults[propertyName] = propertyValue;
	_dirty = true;
}

private function getLineProperty(propertyName: String, lineInfo: Object = null): Object
{
	if ((lineInfo !== null) && (lineInfo.hasOwnProperty(propertyName)))
		return lineInfo[propertyName];
	else if (_lineDefaults.hasOwnProperty(propertyName))
		return _lineDefaults[propertyName];
	else
		return null;
}

private function setWayDefault(propertyName: String, propertyValue: Object): void
{
	_wayDefaults[propertyName] = propertyValue;
	_dirty = true;
}

private function getWayProperty(propertyName: String, wayInfo: Object = null): Object
{
	if ((wayInfo !== null) && (wayInfo.hasOwnProperty(propertyName)))
		return wayInfo[propertyName];
	else if (_wayDefaults.hasOwnProperty(propertyName))
		return _wayDefaults[propertyName];
	else
		return null;
}

private function doTagsMatch(tags: Array, lineInfo: Object): Boolean
{
	var result: Boolean = false;
	if (tags === null)
	{
		result = true;
	}
	else
	{
		if (lineInfo.hasOwnProperty('tags'))
		{
			var myTags: Array = lineInfo.tags;
			
			for each (var myTag: String in myTags)
			{
				for each (var tag: String in tags)
				{
					if (myTag === tag)
						result = true;
				}
			}
			
		}
	}
		
	return result;
}

private function getTagsFromArgument(tagsArgument: Object): Array
{
	if (tagsArgument === null)
		return null;
		
	if (tagsArgument is Array)
		return tagsArgument as Array;
	else
		return [ tagsArgument ];
}

private function addLine(lineInfo: Object): void
{
	_lines.push(lineInfo);
	
	_dirty = true;
}

private function removeLines(tagsArgument: Object = null): void
{
	var tags: Array = getTagsFromArgument(tagsArgument);
	
	for (var index: String in _lines)
	{
		if (doTagsMatch(tags, _lines[index]))
			_lines.splice(index, 1);
	}	
		
	_dirty = true;
}

private function highlightLines(tagsArgument: Object = null): void
{
	var tags: Array = getTagsFromArgument(tagsArgument);

	for (var index: String in _lines)
	{
		if (doTagsMatch(tags, _lines[index]))
			_lines[index].highlighted = true;
	}
	
	_dirty = true;
}

private function unHighlightLines(tagsArgument: Object = null): void
{
	var tags: Array = getTagsFromArgument(tagsArgument);

	for (var index: String in _lines)
	{
		if (doTagsMatch(tags, _lines[index]))
			_lines[index].highlighted = false;
	}
	
	_dirty = true;
}

private function setMouseHandler(eventName: String, functionName: String): void
{
	eventName = eventName.toLowerCase();
	
	if (eventName == 'click')
		_onClickFunction = functionName;
	else if (eventName == 'doubleclick')
		_onDoubleClickFunction = functionName;
	else if (eventName == 'mousedown')
		_onMouseDownFunction = functionName;
	else if (eventName == 'mouseup')
		_onMouseUpFunction = functionName;
	else if (eventName == 'mouseover')
		_onMouseOverFunction = functionName;
	else if (eventName == 'mouseout')
		_onMouseOutFunction = functionName;
	else if (eventName == 'mousemove')
		_onMouseMoveFunction = functionName;
	else
		ExternalInterface.call('alert', 'Unknown event name passed to MapView::setMouseHandler - "'+
			eventName+'" (expected click, doubleclick, mousedown, mouseup, mouseover or mouseout)');
}

private function setSize(width: Number, height: Number): void
{
	_width = width;
	_height = height;
	
	if (_timelineControls !== null)
		_timelineControls.setWidth(width);
	
	_dirty = true;	
}

private function setBorderColor(color: Number): void
{
}

private function setLatLonViewingArea(topLat: Number, leftLon: Number, bottomLat: Number, rightLon: Number): void
{
	var widthLon: Number = (rightLon-leftLon);
	var heightLat: Number = (bottomLat-topLat);
	
	var scaleX: Number = (_width/widthLon);
	var scaleY: Number = (_height/heightLat);

	var newMatrix: Matrix = new Matrix();
	newMatrix.translate(-leftLon, -topLat);
	newMatrix.scale(scaleX, scaleY);

	setLatLonToXYMatrix(newMatrix);
}

private function setLatLonToXYMatrix(newMatrix: Matrix): void
{
//	trace('setLatLonToXYMatrix(): '+newMatrix);
	_latLonToXYMatrix = newMatrix;
	_xYToLatLonMatrix = _latLonToXYMatrix.clone();
	_xYToLatLonMatrix.invert();
}

private function getXYFromLatLon(latLon: Object): Point
{
//	trace('latLon input: '+latLon.lon+', '+latLon.lat);
	var latLonPoint: Point = new Point(latLon.lon, latLon.lat);
	
	var result: Point = _latLonToXYMatrix.transformPoint(latLonPoint);
	
//	trace('latLon transform: '+_latLonToXYMatrix);

//	trace('latLon output: '+result);
	
	return result;
}

private function getLatLonFromXY(xYPoint: Point): Object
{
	var latLonPoint: Point = _xYToLatLonMatrix.transformPoint(xYPoint);
	
	var result: Object = {
			lat: latLonPoint.y,
			lon: latLonPoint.x
	}
	
//	trace('latLon transform: '+_latLonToXYMatrix);

//	trace('latLon output: '+result);
	
	return result;
}

private function setCaption(text: String, lat: Number, lon: Number, color:Number = 0x000000, size:Number=12): void
{
	_caption.htmlText = text;
//	caption.styleName = "text";
//	caption.setStyle("fontSize", size);
//	caption.setStyle("color", color);

trace(text);

	var currentPos: Point = getXYFromLatLon({lat:lat, lon:lon});
	
	_caption.x = (currentPos.x-20);
	_caption.y = (currentPos.y-(size*1.5));
}

private function makeEventArgument(event:MouseEvent): Object
{
	var mouseX: Number = event.localX;
	var mouseY: Number = event.localY;
	
	var mouseLatLon: Object = getLatLonFromXY(new Point(mouseX, mouseY));
	
	var mapPointData:Object = new Object();
	mapPointData.lon = mouseLatLon.lon;
	mapPointData.lat = mouseLatLon.lat;
	mapPointData.x = mouseX;
	mapPointData.y = mouseY;

	return mapPointData;
}
	
private function mapMouseClickHandler( event:MouseEvent ): Boolean
{
	if (_onClickFunction !== null)
		return ExternalInterface.call(_onClickFunction, makeEventArgument(event));
	else
		return true;
}

private function mapMouseDoubleClickHandler( event:MouseEvent ): Boolean
{ 
	if (_onDoubleClickFunction !== null)
		return ExternalInterface.call(_onDoubleClickFunction, makeEventArgument(event));
	else
		return true;
}

private function mapMouseDownHandler( event:MouseEvent ): Boolean
{ 
	if (_onMouseDownFunction !== null)
		return ExternalInterface.call(_onMouseDownFunction, makeEventArgument(event));
	else
		return true;
}

private function mapMouseUpHandler( event:MouseEvent ): Boolean
{ 
	if (_onMouseUpFunction !== null)
		return ExternalInterface.call(_onMouseUpFunction, makeEventArgument(event));
	else
		return true;
}

private function mapMouseOverHandler( event:MouseEvent ): Boolean
{ 
	if (_onMouseOverFunction !== null)
		return ExternalInterface.call(_onMouseOverFunction, makeEventArgument(event));
	else
		return true;
}

private function mapMouseOutHandler( event:MouseEvent ): Boolean
{ 
	if (_onMouseOutFunction !== null)
		return ExternalInterface.call(_onMouseOutFunction, makeEventArgument(event));
	else
		return true;
}

private function mapMouseMoveHandler( event:MouseEvent): Boolean
{ 
	if (_onMouseMoveFunction !== null)
		return ExternalInterface.call(_onMouseMoveFunction, makeEventArgument(event));
	else
		return true;
}

private function doEveryFrame(event: Event): void
{
	if (_onEveryFrameFunction !== null)
		ExternalInterface.call(_onEveryFrameFunction, null);
		
	if (_redrawCountdown>0)
	{
		_redrawCountdown -= 1;
		if (_redrawCountdown===0)
			_dirty = true;
	}
	
	if (_dirty)
	{
		doRedraw();
		_dirty = false;
		_redrawCountdown = 0;
	}
	
	if (_hasTime)
	{
		if (_timelineControls.isPlaying)
		{
			_frameIndex += 1;
			if (_frameIndex>=_frameTimes.length)
				_frameIndex = 0;
			
			updateTimelineDisplay();	
			
			_dirty = true;
		}
	}
	
}

private function blankWay(): Object
{
	var result: Object = {};
	
	result.boundingBox = new Rectangle();
	result.nds = [];
	result.tags = {};
	result.isClosed = false;
	
	for each (var key:String in _wayDefaults)
	{
		result[key] = _wayDefaults[key];
	}

	return result;	
}

private function onXMLLoad(success:Boolean): void
{ 	  		  	
	var xml_data:XML = XML(_xml_loader.data);
  	
  	_tagMap = {};
  	
  	for each (var node: * in xml_data..node)
  	{
  		var newNode: Object = {
  				'lon': (Number)(node.@lon),
  				'lat': (Number)(node.@lat)
  		};
  		
  		_nodes[node.@id] = newNode;
  		
  		trace('Set node '+node.@id+' to '+newNode);
  	}

  	for each (var way: * in xml_data..way)
  	{
		var wayId: String = (String)(way.@id);

  		var newWay: Object = blankWay();
		newWay.id = wayId;
//		newWay.boundingBox = way.bound.@box.explode(',');

		var ndCount: Number = 0;
		var firstNd: String = null;
		var lastNd: String = null;
	  	for each (var nd: * in way..nd)
	  	{
	  		ndCount += 1;
	  		newWay.nds.push(nd.@ref);
	  		
	  		if (firstNd===null)
	  			firstNd = nd.@ref;
	  		lastNd = nd.@ref;
	  		
	  		var thisNode: Object = _nodes[nd.@ref];
	  		var nodePos: Point = new Point(thisNode.lon, thisNode.lat);
	  		newWay.boundingBox = enlargeBoxToContain(newWay.boundingBox, nodePos);
	  	}
	  	
	  	newWay.isClosed = (firstNd===lastNd);
	  	
	  	for each (var tag: * in way..tag)
	  	{
	  		var key: String = tag.@k;
	  		var value: String = tag.@v;
	  		
	  		newWay.tags[key] = value;
	  		
	  		if (typeof _tagMap[key] === 'undefined')
	  			_tagMap[key] = {};
	  			
	  		if (typeof _tagMap[key][value] === 'undefined')
	  			_tagMap[key][value] = [];
	  			
	  		_tagMap[key][value].push(newWay.id);
	  	}

//		trace('Set way to '+newWay.boundingBox);
  		
  		_ways[wayId] = newWay;
  		
  		if (!newWay.boundingBox.isEmpty())
  		{
  			_worldBoundingBox = enlargeBoxToContain(_worldBoundingBox, newWay.boundingBox.topLeft);
  			_worldBoundingBox = enlargeBoxToContain(_worldBoundingBox, newWay.boundingBox.bottomRight);
  		}
  	}

	buildBucketGrid();

	_isLoadingXML = false;
	_dirty = true;
	ExternalInterface.call("onXMLLoaded",_xml_file_name);
}
 	  
private function loadFromXMLFile(xml_file_name: String): void
{
	if (_isLoadingXML)
		return;
 	  		      	
	_isLoadingXML = true;
 	_xml_file_name = xml_file_name;
    _xml_loader = new URLLoader(new URLRequest(xml_file_name));
    _xml_loader.addEventListener("complete", onXMLLoad);
}
 	  
private function isLoadingXML(): Boolean
{
	return _isLoadingXML;
}

private function decodeCSVRow(line: String, columnSeperator: String = ',') : Array
{
	var inQuotes: Boolean = false;
	var inEscape: Boolean = false;
	
	var result: Array = [];

	var currentValue: String = '';

	for( var i: int = 0; i < line.length; i+=1)
	{
		var currentChar: String = line.charAt(i);
	
		if (!inQuotes)
		{
			if (currentChar==='"')
			{
				inQuotes = true;
			}
			else if (currentChar===columnSeperator)
			{
				result.push(currentValue);
				currentValue = '';
			}
			else
			{
				currentValue += currentChar;
			}
		}
		else
		{
			if (!inEscape)
			{
				if (currentChar==='\\')
				{
					inEscape = true;
				}
				else if (currentChar==='"')
				{
					inQuotes = false;
				}
				else
				{
					currentValue += currentChar;
				}
				
			}
			else
			{
				currentValue += currentChar;
				inEscape = false;
			}
			
		}
		
	}
	
	result.push(currentValue);
	
	return result;
}

private function onValuesLoad(success:Boolean): void
{
	var lineSeperator: String = '\n';
	var columnSeperator: String = ',';		  	

	var linesArray: Array = _values_loader.data.toString().split(lineSeperator);
	
	var headerLine: String = linesArray[0];

	_valueHeaders = decodeCSVRow(headerLine, columnSeperator);

	_timeColumnIndex = -1;
	_valueColumnIndex = -1;
	for(var headerIndex:int = 0; headerIndex < _valueHeaders.length; headerIndex++ )
	{
		var header: String = _valueHeaders[headerIndex].toLowerCase();
		trace(header);
		if (header==='time')
			_timeColumnIndex = headerIndex;	
		else if (header==='value')
			_valueColumnIndex = headerIndex;
	}
	
	if (_valueColumnIndex===-1)
	{
		ExternalInterface.call('alert', 'Error loading CSV file "'+_values_file_name+'" - missing value column from header "'+headerLine+'"');
		return;
	}
	
	_hasTime = (_timeColumnIndex!==-1);
	_frameTimes = [];
	var foundTimes: Object = {};
	
	_valueData = [];
	
	for(var i : int = 1; i < linesArray.length; i++ )
	{
		var lineString: String = linesArray[i];
		var lineValues: Array = decodeCSVRow(lineString, columnSeperator);
		
		var thisValue: Number = (Number)(lineValues[_valueColumnIndex]);
		
		if ((i===1)||(thisValue<_smallestValue))
			_smallestValue = thisValue;
			
		if ((i===1)||(thisValue>_largestValue))
			_largestValue = thisValue;
		
		if (_hasTime)
		{
			var thisTime: String = lineValues[_timeColumnIndex];
			if (thisTime !== null)
			{
				if (typeof foundTimes[thisTime] === 'undefined')
				{
					foundTimes[thisTime] = true;
					_frameTimes.push(thisTime);
					_valueData[thisTime] = [];
				}
				
				_valueData[thisTime].push(lineValues);
			}
		}
		else
		{
			_valueData.push(lineValues);		
		}
		
	}
	
	if (_hasTime)
	{
		_frameTimes.sort();
		_frameIndex = 0;
		addTimelineControls();
	}
	
	_dirty = true;		
}
private function loadValuesFromFile(values_file_name: String): void
{
	if (_isLoadingValues)
		return;
		
	_isLoadingValues = true;
	_values_file_name = values_file_name;
	_values_loader = new URLLoader(new URLRequest(values_file_name));
	_values_loader.addEventListener("complete", onValuesLoad);
}

private function getXFromLon(lon:Number): Number
{
	return 0;	
}

private function getYFromLat(lat:Number): Number
{
	return 0;	
}

private function getLonFromX(x:Number): Number
{
	return 0;
}

private function getLatFromY(y:Number): Number
{
	return 0;
}

private function doRedraw(): void
{
	setWaysFromValues();
	
	_drawingSurface.setActualSize(_width, _height);
	_drawingSurface.graphics.clear();

	_drawingSurface.graphics.beginFill(_oceanColor, 1.0);
    _drawingSurface.graphics.drawRect(0, 0, _width, _height);
    _drawingSurface.graphics.endFill();

	var viewingArea: Rectangle = new Rectangle();
	
	var topLeftScreen: Point = new Point(0, 0);
	var bottomRightScreen: Point = new Point(_width, _height);
	
	var topLeftLatLon: Object = getLatLonFromXY(topLeftScreen);
	var bottomRightLatLon: Object = getLatLonFromXY(bottomRightScreen);
	
	viewingArea = enlargeBoxToContain(viewingArea, new Point(topLeftLatLon.lon, topLeftLatLon.lat));
	viewingArea = enlargeBoxToContain(viewingArea, new Point(bottomRightLatLon.lon, bottomRightLatLon.lat));	

	drawWays(viewingArea);
	drawLines();
}

private function drawLines(): void
{
	for each (var line:Object in _lines)
	{
		var lineColor: Number;
		var lineAlpha: Number;
		if (getLineProperty('highlighted', line)==true)
		{
			lineColor = Number(getLineProperty('highlightColor', line));
			lineAlpha = Number(getLineProperty('highlightAlpha', line));
		}
		else
		{
			lineColor = Number(getLineProperty('color', line));
			lineAlpha = Number(getLineProperty('alpha', line));
		}
		
		var lineThickness: Number = Number(getLineProperty('thickness', line));
		
		var lonDistance: Number = (line.toLon-line.fromLon);
		if ((lonDistance>180) || (lonDistance<-180))
		{
			var fromLat: Number;
			var fromLon: Number;
			var toLat: Number;
			var toLon: Number;
			if (lonDistance<-180)
			{
				fromLat = line.fromLat;
				fromLon = line.fromLon;
				toLat = line.toLat;
				toLon = line.toLon;
			}
			else
			{
				fromLat = line.toLat;
				fromLon = line.toLon;
				toLat = line.fromLat;
				toLon = line.fromLon;
			}
			
			var fromX: Number = getXFromLon(fromLon);
			var fromY: Number = getYFromLat(fromLat);
	
			var toX: Number = getXFromLon(toLon);
			var toY: Number = getYFromLat(toLat);
	
			_drawingSurface.graphics.lineStyle(lineThickness,lineColor,lineAlpha);
			_drawingSurface.graphics.beginFill(0);
			_drawingSurface.graphics.moveTo(fromX, fromY);
			_drawingSurface.graphics.lineTo(toX+_width, toY);
			_drawingSurface.graphics.moveTo(fromX-_width, fromY);
			_drawingSurface.graphics.lineTo(toX, toY);
			_drawingSurface.graphics.endFill();
		}
		else
		{
			fromX = getXFromLon(line.fromLon);
			fromY = getYFromLat(line.fromLat);
	
			toX = getXFromLon(line.toLon);
			toY = getYFromLat(line.toLat);
	
			_drawingSurface.graphics.lineStyle(lineThickness,lineColor,lineAlpha);
			_drawingSurface.graphics.beginFill(0);
			_drawingSurface.graphics.moveTo(fromX, fromY);
			_drawingSurface.graphics.lineTo(toX, toY);
			_drawingSurface.graphics.endFill();
		}
	}
}

private function drawWays(viewingArea: Rectangle): void
{		
	for (var wayId:String in _ways)
	{
		var way: Object = _ways[wayId];
		var wayColor: Number;
		var wayAlpha: Number;
		if (getWayProperty('highlighted', way)==true)
		{
			wayColor = Number(getWayProperty('highlightColor', way));
			wayAlpha = Number(getWayProperty('highlightAlpha', way));
		}
		else
		{
			wayColor = Number(getLineProperty('color', way));
			wayAlpha = Number(getLineProperty('alpha', way));
		}

		if (way.nds.length<1)
			continue;
		
		if (!viewingArea.intersects(way.boundingBox))
			continue;
			
		var finalNd: String = way.nds[way.nds.length-1];
		var finalNode: Object = _nodes[finalNd];
		
		var finalPos: Point = getXYFromLatLon(finalNode);
		
		_drawingSurface.graphics.lineStyle();
//		_drawingSurface.graphics.lineStyle(0, wayColor,wayAlpha);
		_drawingSurface.graphics.beginFill(wayColor, wayAlpha);
		_drawingSurface.graphics.moveTo(finalPos.x, finalPos.y);

//		trace("Starting at "+finalPos.x+", "+finalPos.y);
//		trace("Drawing "+way.nds.length+" nodes");

		for each (var currentNd: String in way.nds)
		{
			var currentNode: Object = _nodes[currentNd];
			var currentPos: Point = getXYFromLatLon(currentNode);
			_drawingSurface.graphics.lineTo(currentPos.x, currentPos.y);
//			trace("Line to "+currentPos.x+", "+currentPos.y);
		}

		_drawingSurface.graphics.endFill();
	}
}

private function setWaysFromValues(): void
{
	if (_valueData === null)
		return;

	var currentValues: Array;
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = _valueData[currentTime];
	}
	else
	{
		currentValues = _valueData;
	}
	
	for each (var values: Array in currentValues)
	{
		if (_hasTime)
		{
			var thisTime: String = values[_timeColumnIndex];
			if (thisTime !== currentTime)
				continue;
		}

		var matchKeys: Object = {};
		var thisValue: Number = 0;		
		for (var i:int = 0; i<values.length; i+=1)
		{
			if (i===_valueColumnIndex)
			{
				thisValue = (Number)(values[i]);
			}
			else if (i!==_timeColumnIndex)
			{
				var headerName: String = _valueHeaders[i];
				matchKeys[headerName] = values[i];	
			}
		}
		
		var normalizedValue: Number = ((thisValue-_smallestValue)/(_largestValue-_smallestValue));
		
		var fractionalIndex: Number = (normalizedValue*(_colorGradient.length-1));
		
		var lowerIndex: int = Math.floor(fractionalIndex);
		var higherIndex: int = Math.ceil(fractionalIndex);
		var lerpValue: Number = (fractionalIndex-lowerIndex);
		var oneMinusLerp: Number = (1.0-lerpValue);
		
		var lowerValue: Object = _colorGradient[lowerIndex];
		var higherValue: Object = _colorGradient[higherIndex];
		
		var red: int = (int)((lowerValue.red*oneMinusLerp)+(higherValue.red*lerpValue));
		var green: int = (int)((lowerValue.green*oneMinusLerp)+(higherValue.green*lerpValue));
		var blue: int = (int)((lowerValue.blue*oneMinusLerp)+(higherValue.blue*lerpValue));
		
		var setColor: int = ((red<<16)|(green<<8)|(blue<<0));
		
		setAttributeForMatchingWays(matchKeys, 'color', (String)(setColor));
	}
	
}

private function setColorGradient(colorList: Array) : void
{
	_colorGradient = [];
	
	for each (var colorString: String in colorList)
	{
		var colorNumber: Number = (Number)(colorString);
		var red: Number = (colorNumber&0xff0000)>>16;
		var green: Number = (colorNumber&0x00ff00)>>8;
		var blue: Number = (colorNumber&0x0000ff)>>0;
		
		_colorGradient.push({
			red: red,
			green: green,
			blue: blue
		});
	}	
}

private function setAttributeForMatchingWays(matchKeys: Object, attributeName: String, attributeValue: String) : void
{
	var matchingWayIds: Object = null;
	for (var key:String in matchKeys)
	{
		var value: String = matchKeys[key];
		
		var currentMatches: Array;
		if (typeof _tagMap[key][value] === 'undefined')
			currentMatches = [];
		else
		 	currentMatches = _tagMap[key][value];
		 
		if (matchingWayIds === null)
		{
			matchingWayIds = {};
			for each (var wayId: String in currentMatches)
				matchingWayIds[wayId] = true;
		}
		else
		{
			var previousMatchingWayIds: Object = matchingWayIds;
			matchingWayIds = {};
			for each (wayId in currentMatches)
			{
				if (typeof previousMatchingWayIds[wayId] !== 'undefined')
					matchingWayIds[wayId] = true;
			}
		}
	}
		
	var foundCount: Number = 0;
	for (wayId in matchingWayIds)
	{
		_ways[wayId][attributeName] = attributeValue;
		foundCount += 1;		
	}

//	if ((foundCount===0)&&(matchKeys['state_code']=='12'))
//	{
//		trace('No match found for');
//		for (key in matchKeys)
//		{
//			value = matchKeys[key];	
//			trace(key+':'+value);
//		}
//	}

}

private function enlargeBoxToContain(box: Rectangle, pos: Point): Rectangle
{
	if (box.containsPoint(pos))
		return box;
	
	if ((box.x==0)&&
		(box.y==0)&&
		(box.width==0)&&
		(box.height==0))
		return new Rectangle(pos.x, pos.y, 0, 0);
		
	if (box.left>pos.x)
		box.left = pos.x;

	if (box.right<pos.x)
		box.right = pos.x;

	if (box.top>pos.y)
		box.top = pos.y;
		
	if (box.bottom<pos.y)
		box.bottom = pos.y;
		
	return box;
}

private function buildBucketGrid(): void
{
	_bucketGrid = [];
	
	var originLeft: Number = _worldBoundingBox.left;
	var originTop: Number = _worldBoundingBox.top;
	
	var columnWidth: Number = _worldBoundingBox.width/_bucketGridColumns;
	var rowHeight: Number = _worldBoundingBox.height/_bucketGridRows;
	
	for (var rowIndex: int = 0; rowIndex<_bucketGridRows; rowIndex+=1)
	{
		_bucketGrid[rowIndex] = [];
		
		var rowTop: Number = (originTop+(rowHeight*rowIndex));
		
		for (var columnIndex: int = 0; columnIndex<_bucketGridColumns; columnIndex+=1)
		{
			var columnLeft: Number = (originLeft+(columnWidth*columnIndex));
	
			var boundingBox: Rectangle = new Rectangle(columnLeft, rowTop, columnWidth, rowHeight);

			_bucketGrid[rowIndex][columnIndex] = {
				boundingBox: boundingBox,
				ways: []
			};
		}
	}
	
	for (var wayId:String in _ways)
	{
		var way: Object = _ways[wayId];

		boundingBox = way.boundingBox;
		if (boundingBox.isEmpty())
			continue;
		
		var leftIndex: int = Math.floor((boundingBox.left-originLeft)/columnWidth);
		var rightIndex: int = Math.floor((boundingBox.right-originLeft)/columnWidth);
		var topIndex: int = Math.floor((boundingBox.top-originTop)/rowHeight);
		var bottomIndex: int = Math.floor((boundingBox.bottom-originTop)/rowHeight);

		for (rowIndex=topIndex; rowIndex<=bottomIndex; rowIndex+=1)
		{
			for (columnIndex=leftIndex; columnIndex<=rightIndex; columnIndex+=1)
			{
				_bucketGrid[rowIndex][columnIndex].ways.push(wayId);
			}
		}

	}
}

private function getWaysContainingLatLon(lat: Number, lon: Number): Array
{
	var result: Array = [];

	var pos: Point = new Point(lon, lat);

	if (!_worldBoundingBox.containsPoint(pos))
		return result;
	
	var originLeft: Number = _worldBoundingBox.left;
	var originTop: Number = _worldBoundingBox.top;
	
	var columnWidth: Number = _worldBoundingBox.width/_bucketGridColumns;
	var rowHeight: Number = _worldBoundingBox.height/_bucketGridRows;

	var columnIndex: int = Math.floor((pos.x-originLeft)/columnWidth);
	var rowIndex: int = Math.floor((pos.y-originTop)/rowHeight);
	
	var ways: Array = _bucketGrid[rowIndex][columnIndex].ways;
	
	for each (var wayId: String in ways)
	{
		var way: Object = _ways[wayId];
		if (way.boundingBox.containsPoint(pos))
		{
			if (way.isClosed)
			{
				var xIntersections: Array = [];
	
				var lineStart: Point = null;
				var isFirst: Boolean = true;
				
				for each (var currentNd: String in way.nds)
				{
					var currentNode: Object = _nodes[currentNd];
					var lineEnd: Point = new Point(currentNode.lon, currentNode.lat);
					
					if (isFirst)
					{
						isFirst = false;
					}
					else
					{
						if (((lineStart.y>pos.y)&&(lineEnd.y<pos.y))||
							((lineStart.y<pos.y)&&(lineEnd.y>pos.y)))
						{
							var lineDirection: Point = new Point(lineEnd.x-lineStart.x, lineEnd.y-lineStart.y);
							var yDelta: Number = (pos.y-lineStart.y);
							var yProportion: Number = (yDelta/lineDirection.y);
							
							var xIntersect: Number = (lineStart.x+(lineDirection.x*yProportion));
							xIntersections.push(xIntersect);
						}
						
					}
					
					lineStart = lineEnd;
				}
				
				xIntersections.sort(function(a:Number, b:Number): int {
					if (a<b) return -1;
					else if (a>b) return 1;
					else return 0; 
				});
				
				var isInside: Boolean = false;
				for (var index: int = 0; index<(xIntersections.length-1); index += 2)
				{
					var leftX: Number = xIntersections[index];
					var rightX: Number = xIntersections[(index+1)];
					
					if ((leftX<=pos.x)&&(rightX>pos.x))
						isInside = true;
					
				}
				
				if (isInside)
					result.push(way);
			}
		}
	}
	
	return result;
}

private function addTimelineControls(): void
{
	_timelineControls = new TimelineControls();
	_timelineControls.percentWidth = 100;
	_timelineControls.setWidth(_width-200);
	
	var verticalCenter: Number = ((_height/2)-40);
	_timelineControls.setStyle("verticalCenter", verticalCenter);
	_timelineControls.setTimeTextStyle(12, 0x000000);
	
	_timelineControls.setOnUserInputCallback(onTimelineUserInput);

	addChild(this._timelineControls);
	
	updateTimelineDisplay();
}

private function onTimelineUserInput(dragging: Boolean): void
{
	var sliderValue: Number = _timelineControls.sliderValue;

	var totalFrames: int = _frameTimes.length;

	_frameIndex = Math.round(sliderValue*totalFrames);
	_frameIndex = Math.min(_frameIndex, (totalFrames-1));
	_frameIndex = Math.max(_frameIndex, 0);
	
	updateTimelineDisplay();
	
	if (dragging)
		_redrawCountdown = 5;
	else
		_dirty = true;
}

private function updateTimelineDisplay(): void
{
	var currentTime: String = _frameTimes[_frameIndex];
	_timelineControls.timeText = currentTime;
	
	var totalFrames: int = _frameTimes.length;
	_timelineControls.sliderValue = (_frameIndex/totalFrames);
}

private function getValueForWayId(wayId: String): String
{
	if (typeof _ways[wayId] === 'undefined')
		return null;
		
	var way: Object = _ways[wayId];

	if (_valueData === null)
		return null;

	var currentValues: Array;
	
	if (_hasTime)
	{
		var currentTime: String = _frameTimes[_frameIndex];
		currentValues = _valueData[currentTime];
	}
	else
	{
		currentValues = _valueData;
	}
	
	for each (var values: Array in currentValues)
	{
		var matchKeys: Object = {};
		var thisValue: String = null;		
		for (var i:int = 0; i<values.length; i+=1)
		{
			if (i===_valueColumnIndex)
			{
				thisValue = values[i];
			}
			else if (i!==_timeColumnIndex)
			{
				var headerName: String = _valueHeaders[i];
				matchKeys[headerName] = values[i];	
			}
		}
		
		var allMatch: Boolean = true;
		for (var key: String in matchKeys)
		{
			var value:String = matchKeys[key];
			
			if (way.tags[key]!==value)
				allMatch = false;	
		}
		
		if (allMatch)
			return thisValue;
		
	}
	
	return null;
}

]]>
</mx:Script>
<mx:UIComponent id="viewer"></mx:UIComponent>
	
</mx:Application>
